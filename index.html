<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Qube</title>
    <link rel="icon" href="icons.png" sizes="any">
    <link rel="apple-touch-icon" href="icon.png">
    
    <!-- PWA settings -->
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192x192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Qube">
    <meta name="theme-color" content="#f0f9ff">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;</script>

    <style>
        * {
          box-sizing: border-box;
             }
        /* --- Base Variables from Qube --- */
        :root {
            --bg-primary: #f0f9ff;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e0f2fe;
            --bg-welcome: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --accent-primary: #0ea5e9;
            --accent-primary-hover: #0284c7;
            --accent-primary-shadow: rgba(14, 165, 233, 0.3);
            --border-color: #cbd5e1;
            --modal-bg: rgba(0, 0, 0, 0.5);
            
            /* --- Integrated Variables from BEI --- */
            --button-bg-default: #f1f5f9;
            --button-text-default: #334155;
            --button-border-default: #cbd5e1;
            --progress-bar-bg: var(--accent-primary);
            --feedback-bg: #f8fafc;
            --feedback-border: #e2e8f0;
            --correct-feedback-text: #15803d;
            --correct-feedback-border: #22c55e;
            --incorrect-feedback-text: #b91c1c;
            --incorrect-feedback-border: #ef4444;
            --correct-option-bg: #dcfce7;
            --incorrect-option-bg: #fee2e2;
            --score-color: #0c4a6e;
            --score-comment-color: #0369a1;
            --themed-text-color: #0c4a6e;
            --ai-tutor-user-bg: #e0f2fe;
            --ai-tutor-ai-bg: #f1f5f9;

            /* Safe Area Insets */
            --safe-area-inset-top: env(safe-area-inset-top, 0px);
            --safe-area-inset-bottom: env(safe-area-inset-bottom, 1rem);
        }

        body.dark-mode {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #0c4a6e;
            --bg-welcome: #1e293b;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --accent-primary: #38bdf8;
            --accent-primary-hover: #0ea5e9;
            --accent-primary-shadow: rgba(56, 189, 248, 0.3);
            --border-color: #475569;
            --modal-bg: rgba(0, 0, 0, 0.7);

            /* --- Integrated Dark Variables from BEI --- */
            --button-bg-default: #334155;
            --button-text-default: #e2e8f0;
            --button-border-default: #475569;
            --progress-bar-bg: var(--accent-primary);
            --feedback-bg: #334155;
            --feedback-border: #475569;
            --correct-feedback-text: #a7f3d0;
            --correct-feedback-border: #4ade80;
            --incorrect-feedback-text: #fecaca;
            --incorrect-feedback-border: #f87171;
            --correct-option-bg: #14532d;
            --incorrect-option-bg: #7f1d1d;
            --score-color: #e0f2fe;
            --score-comment-color: #7dd3fc;
            --themed-text-color: #e0f2fe;
            --ai-tutor-user-bg: #0c4a6e;
            --ai-tutor-ai-bg: #334155;
        }
        
        body {
            margin: 0;
            font-family: 'Noto Sans JP', 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden; /* Prevent body scroll */
        }

        /* Splash Screen */
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-primary);
            display: grid;
            place-items: center;
            z-index: 9999;
            transition: opacity 0.9s ease-out;
            will-change: opacity;
        }
        .splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .splash-logo-container {
            position: relative;
            width: 228px;
            height: 228px;
        }
        .splash-logo-container img, .splash-logo-container h1 {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin: 0;
            opacity: 0;
            animation: fadeIn 0.6s 0.2s ease-out forwards;
        }
        .splash-logo-container img {
            width: 100%;
            height: 100%;
        }
        .splash-logo-container h1 {
            display: none;
        }
        .splash-logo-container img:not([src]) + h1,
        .splash-logo-container img[src=""] + h1 {
            display: block;
        }

        /* --- Qube Base Layout --- */
        .main-container { display: flex; height: 100vh; width: 100%; }
        #sidebar { width: 280px; background-color: var(--bg-secondary); border-right: 1px solid var(--border-color); padding: 20px; display: flex; flex-direction: column; transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease; transform: translateX(-100%); position: fixed; top: 0; left: 0; height: 100%; z-index: 1000; padding-top: var(--safe-area-inset-top); }
        #sidebar.open { transform: translateX(0); box-shadow: 0 0 40px rgba(0,0,0,0.2); }
        
        #mainContent { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; transition: margin-left 0.3s ease; }
        body.sidebar-open-desktop #mainContent { margin-left: 280px; }
        
        #mainContent > header { 
            position: relative; 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            padding: 20px; 
            padding-top: calc(20px + var(--safe-area-inset-top)); 
            min-height: 80px;
            gap: 1rem;
        }
        #headerLeft, #headerRight {
        flex-shrink: 0; /* ボタンのある左右の領域は縮まないように固定 */
        display: flex;
        align-items: center;
        gap: 0.5rem;
        }
    
        #headerCenter {
            flex-grow: 1; /* 中央の領域は利用可能なスペースいっぱいに広がる */
            text-align: center;
        
            /* 最も重要な設定：これによりflexアイテムがコンテンツ幅より小さくなることを許可 */
            min-width: 0;
        }
        #projectTitle {
            font-weight: 700;
            font-size: 1.875rem;
            line-height: 1.25;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: inline-block;
            max-width: 100%;
            vertical-align: middle;
        }
        
        #screenContainer { flex-grow: 1; overflow-y: auto; padding: 20px; padding-bottom: calc(20px + var(--safe-area-inset-bottom)); display: flex; flex-direction: column; }

        @media (max-width: 767px) { 
            body.sidebar-open-desktop #mainContent { margin-left: 0; }
            #projectTitle { font-size: 1.25rem; }
        }
        .sidebar-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999; }
        .sidebar-overlay.active { display: block; }

        .screen { 
            display: none; 
            flex-direction: column; 
            width: 100%; 
        }
        .screen.active { 
            display: flex;
            flex-grow: 1;
        }

        #projectStartScreen.active {
            justify-content: center;
        }

        .project-item { position: relative; display: flex; align-items: center; justify-content: space-between; padding: 8px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
        .project-item:hover { background-color: var(--bg-tertiary); }
        .project-item.active { background-color: var(--bg-tertiary); font-weight: bold; }
        .project-item.dragging { opacity: 0.7; background-color: var(--accent-primary); color: white; box-shadow: 0 8px 20px rgba(0,0,0,0.2); z-index: 10; }
        .project-name { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .project-menu-btn { padding: 4px; border-radius: 50%; flex-shrink: 0; }
        .project-menu-btn:hover { background-color: rgba(0,0,0,0.1); }
        .project-menu { position: absolute; top: 100%; right: 5px; background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); z-index: 1100; display: none; min-width: 120px; margin-top: 4px;}
        .project-menu.show { display: block; }
        .project-menu-item { padding: 8px 16px; cursor: pointer; display: flex; align-items: center;}
        .project-menu-item:hover { background-color: var(--bg-tertiary); }
        .project-menu-item.delete { color: #ef4444; }

        .btn { padding: 10px 20px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; border: none; }
        .btn-primary { background-color: var(--accent-primary); color: white; box-shadow: 0 4px 12px var(--accent-primary-shadow); }
        .btn-primary:hover:not(:disabled) { background-color: var(--accent-primary-hover); transform: translateY(-2px); }
        .btn-lg { padding: 15px 30px; font-size: 1.1rem; }
        .btn:disabled { opacity: 0.7; cursor: not-allowed; }
        .btn-sm { padding: 4px 12px; font-size: 0.875rem; }
        .btn-danger { background-color: #ef4444; color: white; }
        .btn-danger:hover:not(:disabled) { background-color: #dc2626; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); background-color: var(--bg-secondary); color: var(--text-primary); font-size: 1rem; }
        .form-group textarea { min-height: 120px; resize: vertical; }
        #fillInBlankInput {
            width: 100%;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 1.2rem;
            text-align: center;
        }
        
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--modal-bg); display: flex; justify-content: center; align-items: center; z-index: 2000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal.show { opacity: 1; visibility: visible; }
        .modal-content { background-color: var(--bg-secondary); padding: 30px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); max-width: 400px; width: 90%; transform: translateY(-20px) scale(0.95); transition: transform 0.3s ease, background-color 0.3s ease; }
        .modal.show .modal-content { transform: translateY(0) scale(1); }
        .modal-title { font-size: 1.5rem; font-weight: 700; color: var(--text-primary); margin-bottom: 20px; }
        .modal-buttons { display: flex; justify-content: flex-end; gap: 10px; margin-top: 25px; }
        .modal-button { padding: 10px 25px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; border: none; }
        .modal-button.create, .modal-button.save { background-color: var(--accent-primary); color: white; }
        .modal-button.create:hover, .modal-button.save:hover { background-color: var(--accent-primary-hover); }
        .modal-button.delete, .modal-button.reset { background-color: #ef4444; color: white; }
        .modal-button.delete:hover, .modal-button.reset:hover { background-color: #dc2626; }
        .modal-button.cancel { background-color: transparent; color: var(--text-secondary); border: 1px solid var(--border-color); }
        .modal-button.cancel:hover { background-color: var(--border-color); }

        #tosModal .modal-content { max-width: 500px; }
        #tosContent { max-height: 30vh; overflow-y: auto; background-color: var(--bg-primary); padding: 1rem; border-radius: 8px; font-size: 0.9rem; color: var(--text-secondary); border: 1px solid var(--border-color); }

        #addToHomeScreenPopup {
            display: none;
            position: fixed;
            bottom: calc(20px + var(--safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            z-index: 4000;
            width: 90%;
            max-width: 400px;
        }
        #addToHomeScreenPopup::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid var(--bg-secondary);
        }
        #closeAddToHomeScreen {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 24px;
        }

        #welcomeScreen, #projectStartScreen .start-screen-container {
            background-color: var(--bg-welcome);
            transition: background-color 0.3s ease;
        }
        .start-screen-container { 
            max-width: 600px; 
            text-align: center; 
            margin: auto;
            padding: 3rem;
            border-radius: 1rem;
        }
        .start-screen-container h2 { color: var(--themed-text-color); }
        .start-screen-container .form-group select {
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2020%2020%22%20fill%3D%22%2364748b%22%3E%3Cpath%20fill-rule%3D%22evenodd%22%20d%3D%22M5.293%207.293a1%201%200%20011.414%200L10%2010.586l3.293-3.293a1%201%200%20111.414%201.414l-4%204a1%201%200%2001-1.414%200l-4-4a1%201%200%20010-1.414z%22%20clip-rule%3D%22evenodd%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 1.2em;
        }
        #fileDropArea { border-color: var(--border-color); }
        #fileDropArea.dragover { border-color: var(--accent-primary); background-color: var(--bg-tertiary); }
        #filePreviewContainer { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 1rem; }
        .file-preview-item { position: relative; display: flex; flex-direction: column; align-items: center; }
        .file-preview-item img, .file-preview-item canvas { max-height: 100px; border-radius: 8px; }
        .file-preview-item .file-name { font-size: 0.8rem; color: var(--text-secondary); max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .remove-file-btn { position: absolute; top: -8px; right: -8px; background: #ef4444; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; border: 2px solid var(--bg-secondary); }
        .divider { text-align: center; margin: 1.5rem 0; color: var(--text-secondary); display: flex; align-items: center; gap: 1rem; }
        .divider::before, .divider::after { content: ''; height: 1px; background-color: var(--border-color); flex-grow: 1; }

        .quiz-container { max-width: 800px; margin-left: auto; margin-right: auto; width: 100%; }
        #quizHeader { display: flex; flex-direction: column; gap: 1rem; }
        #quizTitleArea { display: flex; justify-content: center; align-items: center; min-height: 40px; }
        #quizTitle { font-size: 1.5rem; font-weight: 700; color: var(--themed-text-color); text-align: center; line-height: 1.3; }
        .progress-container { width: 100%; background-color: #e2e8f0; border-radius: 10px; height: 15px; overflow: hidden; box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        .progress-bar { height: 100%; width: 0%; background-color: var(--progress-bar-bg); border-radius: 10px; transition: width 0.4s ease-in-out; }
        .progress-text { font-size: 1rem; font-weight: 600; color: var(--text-primary); transition: color 0.3s ease; text-align: center; }
        .question-area { min-height: 100px; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: background-color 0.3s ease; text-align: left; margin-top: 1.5rem;}
        #questionImage { max-height: 200px; border-radius: 8px; margin-top: 1rem; }
        .question-text { font-size: 1.25rem; font-weight: 500; color: var(--themed-text-color); margin-bottom: 10px; transition: color 0.3s ease; width: 100%; text-align:center; }
        #longContentBox { display: none; width: 100%; max-height: 250px; overflow-y: auto; background-color: var(--button-bg-default); border: 1px solid var(--border-color); padding: 1rem; border-radius: 8px; margin-bottom: 1rem; white-space: pre-wrap; font-family: inherit; font-size: 1rem; }
        .options-grid { display: grid; grid-template-columns: 1fr; gap: 12px; margin-top: 15px; }
        .options-grid.options-grid-full-width { grid-template-columns: 1fr; }
        .option-button { background-color: var(--button-bg-default); color: var(--button-text-default); padding: 14px 20px; border-radius: 12px; font-size: 1rem; font-weight: 500; cursor: pointer; transition: all 0.3s ease; border: 2px solid var(--button-border-default); text-align: left; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08); line-height: 1.5; }
        .option-button:hover:not(:disabled) { background-color: var(--border-color); transform: translateY(-3px) scale(1.01); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.12); }
        .option-button.correct { background-color: var(--correct-option-bg); border-color: var(--correct-feedback-border); color: var(--correct-feedback-text); }
        .option-button.incorrect { background-color: var(--incorrect-option-bg); border-color: var(--incorrect-feedback-border); color: var(--incorrect-feedback-text); }
        .option-button.selected { border-color: var(--accent-primary); background-color: var(--bg-tertiary); }
        .option-button:disabled { cursor: not-allowed; }
        .sorting-item.dragging { opacity: 0.5; }
        .sorting-container { display: flex; flex-direction: column; gap: 1rem; }
        .sorting-box { display: flex; flex-wrap: wrap; gap: 10px; padding: 1rem; border-radius: 12px; border: 2px dashed var(--border-color); min-height: 70px; }
        .feedback-message { margin-top: 1.5rem; font-size: 1rem; text-align: left; padding: 1rem 1.5rem; border-radius: 12px; background-color: var(--feedback-bg); border: 1px solid var(--feedback-border); box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); line-height: 1.5; }
        .feedback-message.correct-feedback { color: var(--correct-feedback-text); border-color: var(--correct-feedback-border); }
        .feedback-message.incorrect-feedback { color: var(--incorrect-feedback-text); border-color: var(--incorrect-feedback-border); }
        .feedback-header { display: flex; justify-content: space-between; align-items: center; gap: 15px; min-height: 24px; flex-wrap: wrap; }
        #feedbackResult { flex-grow: 1; }
        .feedback-result strong { font-size: 1.1rem; }
        .explanation-content { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out, padding-top 0.4s ease-out, margin-top 0.4s ease-out; padding-top: 0; margin-top: 0; }
        .explanation-content.show { max-height: 200px; padding-top: 10px; margin-top: 10px; border-top: 1px solid var(--border-color); }
        .explanation-text { font-weight: 400; font-size: 0.95rem; }
        .toggle-explanation-button { background-color: var(--accent-primary); color: white; padding: 6px 12px; border-radius: 8px; font-size: 0.8rem; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease; flex-shrink: 0; border: none; }
        .navigation-buttons { display: flex; justify-content: flex-end; margin-top: 20px; flex-wrap: wrap; gap: 10px; }
        
        .result-container { text-align: center; max-width: 600px; margin: 2rem auto; }
        .score-area { font-size: 1.8rem; font-weight: 800; color: var(--score-color); margin-top: 25px; }
        .score-comment { font-size: 1.3rem; font-weight: 700; color: var(--score-comment-color); margin-top: 10px; }
        .confetti-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none; z-index: 0; }
        .confetti { position: absolute; width: 10px; height: 10px; background-color: #f06; opacity: 1; }

        #settingsScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        #settingsScreen.active {
            opacity: 1;
            visibility: visible;
        }
        #settingsScreen .settings-container, #editQuizzesModal .modal-content {
            background-color: var(--bg-secondary);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-width: 700px;
            width: 90%;
            transform: translateY(-20px) scale(0.95);
            transition: transform 0.3s ease, background-color 0.3s ease;
            max-height: 85vh;
            overflow-y: auto;
        }
        #settingsScreen.active .settings-container, #editQuizzesModal.show .modal-content {
            transform: translateY(0) scale(1);
        }
        .settings-option { display: flex; justify-content: space-between; align-items: center; padding: 16px 0; border-bottom: 1px solid var(--border-color); flex-wrap: nowrap; gap: 1rem;}
        .settings-option:last-child { border-bottom: none; }
        .settings-option-label { display: flex; flex-direction: column; align-items: flex-start; flex-grow: 1; min-width: 0; }
        .settings-option-label label { font-size: 1.1rem; color: var(--text-primary); font-weight: 600; }
        .settings-option-label p { font-size: 0.85rem; color: var(--text-secondary); margin: 4px 0 0 0; text-align: left; }
        .theme-colors { display: flex; gap: 10px; }
        .color-circle { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; transition: border-color 0.2s ease; }
        .color-circle.selected { border-color: var(--accent-primary); }
        .toggle-switch { position: relative; display: inline-block; width: 60px; height: 34px; flex-shrink: 0; margin-left: auto; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-primary); }
        input:checked + .slider:before { transform: translateX(26px); }
        
        #settingsScreen select, #soundVolumeSlider {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--border-color);
        }
        #soundVolumeSlider {
            -webkit-appearance: none;
            appearance: none;
            width: 128px;
            height: 8px;
            background: var(--border-color);
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        #soundVolumeSlider:hover { opacity: 1; }
        #soundVolumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
        }
        #soundVolumeSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
        }

        #editQuizzesModal .modal-content { max-width: 600px; }
        #editQuizList .project-item { padding-left: 0; }
        .drag-handle { touch-action: none; cursor: move; padding: 8px; }
        #editQuizList .project-item.dragging {
            opacity: 0.7;
            background: var(--bg-tertiary);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .tab-button {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            font-weight: 600;
        }
        .tab-button.active {
            color: var(--accent-primary);
            border-bottom-color: var(--accent-primary);
        }
        #importProjectContainer {
            display: none;
        }

        /* ★★★ 変更箇所 START ★★★ */
        /* --- AI Tutor Styles (MODIFIED FOR STICKY INPUT) --- */
        #aiTutorScreen .quiz-container {
            max-width: 800px;
            display: flex;
            flex-direction: column;
            height: 100%; /* 親要素の高さいっぱいに広げる */
        }
        

        .ai-tutor-problem-statement {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem;
            text-align: left;
            margin-bottom: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }
        body.dark-mode .ai-tutor-problem-statement {
             box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .ai-tutor-problem-statement p {
            color: var(--text-primary);
            font-size: 1rem;
            line-height: 1.6;
        }
        .ai-tutor-problem-statement .correct-answer {
            font-weight: 700;
            color: var(--correct-feedback-text);
            background-color: var(--correct-option-bg);
            padding: 2px 6px;
            border-radius: 6px;
        }
        #toggleOtherOptionsButton {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            margin-top: 10px;
            background: none;
            border: none;
            padding: 0;
        }
        #otherOptionsContainer {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px dashed var(--button-border-default);
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        #aiTutorChatLog {
            flex-grow: 1; /* 利用可能なスペースをすべて埋める */
            overflow-y: auto; /* 内容が多ければスクロールさせる */
            border: 1px solid var(--button-border-default);
            border-radius: 12px;
            padding: 15px;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background-color: var(--bg-primary);
            margin-bottom: 15px; /* 入力フォームとの間に余白を追加 */
        }
        .chat-message {
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 85%;
            line-height: 1.6;
            color: var(--text-primary);
            word-wrap: break-word;
        }
        .chat-message.user {
            background-color: var(--ai-tutor-user-bg);
            align-self: flex-end;
            border-bottom-right-radius: 3px;
        }
        .chat-message.ai {
            background-color: var(--ai-tutor-ai-bg);
            align-self: flex-start;
            border-bottom-left-radius: 3px;
        }
        .chat-message.loading {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .dot-flashing {
            position: relative;
            width: 5px; height: 5px;
            border-radius: 5px;
            background-color: var(--text-secondary);
            color: var(--text-secondary);
            animation: dotFlashing 1s infinite linear alternate;
            animation-delay: .5s;
        }
        .dot-flashing::before, .dot-flashing::after {
            content: ''; display: inline-block; position: absolute; top: 0;
        }
        .dot-flashing::before {
            left: -10px; width: 5px; height: 5px; border-radius: 5px;
            background-color: var(--text-secondary); color: var(--text-secondary);
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 0s;
        }
        .dot-flashing::after {
            left: 10px; width: 5px; height: 5px; border-radius: 5px;
            background-color: var(--text-secondary); color: var(--text-secondary);
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 1s;
        }
        @keyframes dotFlashing {
            0% { background-color: var(--text-secondary); }
            50%, 100% { background-color: rgba(156, 163, 175, 0.2); }
        }
        #aiTutorInputForm {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            flex-shrink: 0; /* コンテナが縮んでも自身のサイズを維持 */
        }
        #aiTutorInput {
            flex-grow: 1; min-width: 150px; padding: 12px; border-radius: 8px;
            border: 1px solid var(--border-color); font-size: 1rem;
            background-color: var(--bg-secondary); color: var(--text-primary);
        }
        #voiceInputButton {
            flex-shrink: 0; width: 48px; height: 48px; border-radius: 8px;
            background-color: var(--button-bg-default); border: 1px solid var(--border-color);
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; transition: all 0.2s ease;
        }
        #voiceInputButton:hover { background-color: var(--border-color); }
        #voiceInputButton.recording { background-color: #f87171; border-color: #ef4444; }
        #voiceInputButton.recording svg { color: white; animation: pulse 1.5s infinite; }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        #aiTutorSubmitButton { flex-shrink: 0; height: 48px; }


        @media (min-width: 640px) { 
            .options-grid { grid-template-columns: 1fr 1fr; }
            #sidebar > div:first-child {
                margin-top: 20px;
            }
        }
        body {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      #questionText, 
      #longContentBox, 
      #aiTutorQuestionText, 
      #aiTutorChatLog .chat-message,
      .feedback-message,
      .start-screen-container p {
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
      }
        img {
        pointer-events: none;
      }
        .loader {
  border: 5px solid var(--bg-tertiary);
  border-top: 5px solid var(--accent-primary);
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin: 20px auto;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
    </style>
</head>
<body>
    <script>
        try {
            const savedData = localStorage.getItem('qube_app_data');
            if (savedData) {
                const settings = JSON.parse(savedData).settings;
                if (settings && settings.darkMode) {
                    document.body.classList.add('dark-mode');
                }
            }
        } catch (e) {
            console.error('Failed to apply dark mode setting on initial load:', e);
        }
    </script>

    <!-- Splash Screen -->
    <div id="splashScreen" class="splash-screen">
        <div class="splash-logo-container">
            <img src="iconsp.png" alt="Qube Logo" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
            <h1 class="text-5xl font-bold" style="color: var(--accent-primary);">Qube</h1>
        </div>
    </div>

    <div id="confettiContainer" class="confetti-container"></div>
    <div class="main-container">
        <!-- Sidebar -->
        <aside id="sidebar">
            <div class="flex items-center mb-6 h-10">
                <img src="iconp.png" alt="Qube Logo" class="h-11 w-28" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                <h2 class="text-2xl font-bold ml-2" style="color: var(--accent-primary); display: none;">Qube</h2>
            </div>
            <button id="newProjectButton" class="btn btn-primary w-full mb-6">新しいプロジェクトを作成</button>
            <h3 class="text-lg font-semibold mb-3 text-gray-500">プロジェクト一覧</h3>
            <div id="projectList" class="flex-grow overflow-y-auto space-y-1 pr-2">
                <p class="text-gray-400">まだプロジェクトがありません。</p>
            </div>
        </aside>
        <div id="sidebarOverlay" class="sidebar-overlay"></div>

        <!-- Main Content -->
        <main id="mainContent">
            <header>
                <div id="headerLeft">
                    <button id="hamburgerButton" class="p-2 rounded-md">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
                    </button>
                </div>
                <div id="headerCenter">
                    <h1 id="projectTitle"></h1>
                </div>
                <div id="headerRight">
                     <button id="interruptButton" class="btn btn-sm btn-danger hidden">中断</button>
                     <button id="projectSettingsButton" class="p-2 rounded-md invisible">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
                     </button>
                </div>
            </header>
            
            <div id="screenContainer">
                <div id="welcomeScreen" class="screen active flex-col justify-center items-center text-center p-8 rounded-lg">
                    <img src="iconsp.png" alt="Qube ロゴ" class="h-25 mb-6 mx-auto">
                    <p class="text-xl mb-8" style="color: var(--text-secondary);">AIの力で、あなたの学習を次のレベルへ。</p>
                    <button id="getStartedButton" class="btn btn-primary text-lg px-8 py-3">さっそく始める</button>
                </div>

                <div id="projectStartScreen" class="screen">
                    <div class="start-screen-container">
                        <h2 class="text-3xl font-bold mb-6">学習を開始</h2>
                        <div class="form-group">
                            <label for="quizSelect" class="text-left">作成済みクイズから選ぶ</label>
                            <select id="quizSelect"></select>
                        </div>
                        <button id="startSelectedQuizButton" class="btn btn-primary btn-lg w-full">選択したクイズを開始</button>
                        <button id="aiTutorButton" class="btn btn-lg w-full mt-4" style="background-color: #10b981; color: white;">🤖 AIチューターと話す</button>
                        <div class="divider">または</div>
                        <button id="generateNewQuizBtn" class="btn btn-lg w-full" style="background-color: var(--button-bg-default); color: var(--button-text-default); border: 1px solid var(--border-color);">新しいクイズをAIで生成</button>
                    </div>
                </div>
                
                <div id="generationScreen" class="screen">
                    <div class="max-w-3xl mx-auto w-full mb-16">
                        <div class="flex border-b border-gray-200 dark:border-gray-700 mb-6">
                            <button id="generateTabButton" class="tab-button active">新しく生成する</button>
                            <button id="importTabButton" class="tab-button">外部から読み込む</button>
                        </div>
                        <div id="generateProjectContainer">
                             <div class="form-group">
                                <label>ファイルをアップロード</label>
                                <div id="fileDropArea" class="w-full p-8 border-2 border-dashed rounded-lg text-center cursor-pointer hover:border-sky-500">
                                    <p class="text-gray-500">ここにファイルをドラッグ＆ドロップ<br>またはクリックして選択</p>
                                    <input type="file" class="hidden" id="fileUpload" multiple>
                                </div>
                                <div id="filePreviewContainer"></div>
                            </div>
                            <div class="divider">または</div>
                            <div class="form-group">
                                <label id="promptLabel" for="promptText">クイズにしたい内容（プロンプト）</label>
                                <textarea id="promptText" placeholder="例:「英語の長文問題を作成してください。中学レベルで、ポスターから内容を読み取る問題にしてください。」　または　「日本の首都は東京です。徳川家康は江戸幕府を開きました...」"></textarea>
                            </div>
                            <div class="grid md:grid-cols-2 gap-4 mt-8">
                                <div class="form-group">
                                    <label for="genQuestionCount">問題数</label>
                                    <select id="genQuestionCount">
                                        <option value="5">5問</option>
                                        <option value="10">10問</option>
                                        <option value="15">15問</option>
　                                      <option value="20">20問</option>
                                        <option value="25">25問</option>
　                                      <option value="30">30問</option>
                                        <option value="all">全て</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="questionType">問題形式</label>
                                    <select id="questionType">
                                        <option value="auto_select">適切なものを選ぶ</option>
                                        <option value="multiple_choice">選択肢</option>
                                        <option value="fill_in_the_blank">記述式</option>
                                        <option value="sorting">並び替え</option>
                                        <option value="multiple_select">複数選択</option>
                                    </select>
                                </div>
                            </div>
                             <div class="mt-4">
                                <label class="flex items-center gap-2 cursor-pointer flex-nowrap">
                                    <input type="checkbox" id="autoGenreCheckbox" class="w-4 h-4 accent-sky-500 flex-shrink-0">
                                    <span class="select-none">AIによる自動ジャンル分け</span>
                                </label>
                            </div>
                            <button id="generateQuizButton" class="btn btn-primary w-full mt-4 py-3 text-lg flex items-center justify-center">
                                <span class="button-text">クイズを生成する</span>
                                <svg class="spinner hidden animate-spin ml-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                            </button>
                            <p id="generationWarning" class="text-red-500 text-sm mt-2 text-center hidden"></p>
                            <p id="generationError" class="text-red-500 text-sm mt-2 text-center hidden"></p>
                            <button id="backToProjectStartBtn" class="btn w-full mt-4" style="background-color: var(--button-bg-default); color: var(--button-text-default); border: 1px solid var(--border-color);">プロジェクトに戻る</button>
                        </div>
                        <div id="importProjectContainer">
                            <div class="form-group">
                                <label for="importFileInput">共有ファイル (.txt) を選択</label>
                                <input type="file" id="importFileInput" accept=".txt, text/plain" class="w-full p-2 border rounded-lg">
                            </div>
                            <div class="mt-4">
                               <label class="flex items-center gap-2 cursor-pointer flex-nowrap">
                                   <input type="checkbox" id="importMasteryCheckbox" class="w-4 h-4 accent-sky-500 flex-shrink-0" checked>
                                   <span class="select-none">共有元の学習状況（習熟度）を反映する</span>
                               </label>
                           </div>
                            <button id="importProjectButton" class="btn btn-primary w-full mt-4 py-3 text-lg">プロジェクトを読み込む</button>
                            <p id="importStatusMessage" class="text-sm mt-2 text-center"></p>
                        </div>
                    </div>
                </div>

                <div id="quizScreen" class="screen">
                    <div class="quiz-container">
                        <div id="quizHeader">
                            <div id="quizTitleArea">
                                <h1 id="quizTitle">クイズ</h1>
                            </div>
                            <div class="progress-container">
                                <div id="progressBar" class="progress-bar"></div>
                            </div>
                            <div id="progressText" class="progress-text"></div>
                        </div>
                        <div class="question-area">
                            <div id="questionText" class="question-text"></div>
                            <img id="questionImage" class="hidden"/>
                            <div id="longContentBox"></div>
                        </div>
                        <div id="optionsGrid" class="options-grid"></div>
                        <div id="submissionArea" class="mt-4 text-right"></div>
                        <div id="feedbackMessage" class="feedback-message" style="visibility: hidden;">
                            <div class="feedback-header">
                                <div id="feedbackResult"></div>
                                <button id="toggleExplanationButton" class="toggle-explanation-button hidden">解説▼</button>
                            </div>
                            <div id="explanationContent" class="explanation-content">
                                <div class="explanation-text"></div>
                            </div>
                        </div>
                        <div class="navigation-buttons">
                            <button id="nextButton" class="btn btn-primary">次の問題</button>
                        </div>
                    </div>
                </div>

                <div id="aiTutorScreen" class="screen">
                    <div class="quiz-container">
                        <div id="aiTutorActionsContainer" class="mb-4 text-right hidden"></div>
                        <div class="ai-tutor-problem-statement">
                            <p id="aiTutorQuestionText"></p>
                            <button id="toggleOtherOptionsButton">他の選択肢を見る▼</button>
                            <div id="otherOptionsContainer" style="display: none;"></div>
                        </div>
                        <div id="aiTutorChatLog"></div>
                        <form id="aiTutorInputForm">
                            <input type="text" id="aiTutorInput" placeholder="なぜこの答えになるか説明してみよう！" autocomplete="off">
                            <button type="button" id="voiceInputButton">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--text-secondary);">
                                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                                    <line x1="12" y1="19" x2="12" y2="23"></line>
                                </svg>
                            </button>
                            <button type="submit" id="aiTutorSubmitButton" class="btn btn-primary">送信</button>
                        </form>
                    </div>
                </div>

                <div id="resultScreen" class="screen">
                    <div class="result-container">
                        <h2 class="text-2xl font-bold mb-4" style="color: var(--score-color);">クイズ結果</h2>
                        <div id="finalScore" class="score-area"></div>
                        <div id="scoreComment" class="score-comment"></div>
                        <div class="mt-6 flex flex-col items-center gap-3">
                            <button id="restartQuizButton" class="btn btn-primary w-full max-w-xs">もう一度挑戦</button>
                            <button id="backToProjectButton" class="btn w-full max-w-xs" style="background-color: var(--button-bg-default); color: var(--button-text-default); border: 1px solid var(--border-color);">プロジェクトに戻る</button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Settings Screen (Modal) -->
    <div id="settingsScreen" class="screen">
        <div class="settings-container">
            <h2 class="text-2xl font-bold mb-4 text-center">設定</h2>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label for="darkModeToggle">ダークモード</label>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="darkModeToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label>テーマカラー</label>
                </div>
                <div class="theme-colors">
                    <div class="color-circle" data-theme="default" style="background-color: #0ea5e9;"></div>
                    <div class="color-circle" data-theme="red" style="background-color: #ef4444;"></div>
                    <div class="color-circle" data-theme="green" style="background-color: #10b981;"></div>
                    <div class="color-circle" data-theme="indigo" style="background-color: #6366f1;"></div>
                </div>
            </div>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label for="soundVolumeSlider">効果音</label>
                </div>
                <div class="flex items-center gap-2">
                    <span id="volumeStatus" class="text-sm text-gray-500 w-8 text-right"></span>
                    <input type="range" id="soundVolumeSlider" min="0" max="100">
                </div>
            </div>
             <div class="settings-option">
                <div class="settings-option-label">
                    <label for="questionCountSelect">問題数</label>
                </div>
                <select id="questionCountSelect" class="w-24 p-2 border rounded">
                    <option value="5">5問</option>
                    <option value="10">10問</option>
                    <option value="15">15問</option>
                    <option value="20">20問</option>
                    <option value="25">25問</option>
                    <option value="30">30問</option>
                    <option value="99">全て</option>
                </select>
            </div>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label for="shuffleQuestionsToggle">シャッフル出題</label>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="shuffleQuestionsToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label for="showProgressToggle">進捗状況を表示</label>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="showProgressToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label for="masteryModeToggle">特訓モード</label>
                    <p>2回連続で正解するまで「習得済み」になりません。</p>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="masteryModeToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="settings-option">
                <div class="settings-option-label">
                    <label>プロジェクトの共有</label>
                    <p>現在のプロジェクトを書き出して共有します。</p>
                </div>
                <button id="exportProjectButton" class="btn">書き出す</button>
            </div>
             <div class="settings-option">
                <button id="editQuizzesButton" class="btn w-full">作成済みクイズを編集する</button>
            </div>
            <button id="backToProjectFromSettings" class="btn btn-primary mt-8 w-full">閉じる</button>
        </div>
    </div>
    
    <!-- Modals -->
    <div id="newProjectModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">新しいプロジェクトの作成</h2>
            <div class="form-group">
                <label for="newProjectNameInput">プロジェクト名</label>
                <input type="text" id="newProjectNameInput" placeholder="例: 歴史クイズ">
            </div>
            <div class="modal-buttons">
                <button id="modalCancelProjectButton" class="modal-button cancel">キャンセル</button>
                <button id="modalCreateProjectButton" class="modal-button create">作成</button>
            </div>
        </div>
    </div>
    <div id="renameProjectModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">プロジェクト名を変更</h2>
            <div class="form-group">
                <label for="renameProjectNameInput">新しいプロジェクト名</label>
                <input type="text" id="renameProjectNameInput">
            </div>
            <div class="modal-buttons">
                <button id="modalCancelRenameButton" class="modal-button cancel">キャンセル</button>
                <button id="modalSaveRenameButton" class="modal-button save">保存</button>
            </div>
        </div>
    </div>
    <div id="nameQuizModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">クイズに名前を付ける</h2>
            <div class="form-group">
                <label for="newQuizNameInput">クイズ名</label>
                <input type="text" id="newQuizNameInput" placeholder="例: 江戸時代クイズ">
            </div>
            <div class="modal-buttons">
                <button id="modalCancelQuizButton" class="modal-button cancel">キャンセル</button>
                <button id="modalCreateQuizButton" class="modal-button create">保存</button>
            </div>
        </div>
    </div>
     <div id="interruptModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">クイズを中断</h2>
            <p>本当にクイズを中断しますか？現在の進捗は保存されません。</p>
            <div class="modal-buttons">
                <button id="modalCancelInterrupt" class="modal-button cancel">キャンセル</button>
                <button id="modalConfirmInterrupt" class="modal-button delete">中断する</button>
            </div>
        </div>
    </div>
    <div id="deleteProjectModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">プロジェクトを削除</h2>
            <p>本当に「<span id="deleteProjectName"></span>」を削除しますか？この操作は元に戻せません。</p>
            <div class="modal-buttons">
                <button id="modalCancelDelete" class="modal-button cancel">キャンセル</button>
                <button id="modalConfirmDelete" class="modal-button delete">削除する</button>
            </div>
        </div>
    </div>
    
    <div id="editQuizzesModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">クイズの編集</h2>
            <div id="editQuizList" class="space-y-2">
            </div>
            <div class="modal-buttons">
                <button id="closeEditQuizModalButton" class="modal-button cancel">閉じる</button>
            </div>
        </div>
    </div>
    <div id="renameQuizInstanceModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">クイズ名を変更</h2>
            <div class="form-group">
                <label for="renameQuizNameInstanceInput">新しいクイズ名</label>
                <input type="text" id="renameQuizNameInstanceInput">
            </div>
            <div class="modal-buttons">
                <button class="modal-button cancel">キャンセル</button>
                <button class="modal-button save">保存</button>
            </div>
        </div>
    </div>
    <div id="deleteQuizInstanceModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">クイズを削除</h2>
            <p>本当に「<span id="deleteQuizNameInstance"></span>」を削除しますか？この操作は元に戻せません。</p>
            <div class="modal-buttons">
                <button class="modal-button cancel">キャンセル</button>
                <button class="modal-button delete">削除する</button>
            </div>
        </div>
    </div>
    <div id="resetMasteryModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">学習完了！</h2>
            <p>このクイズのすべての問題を習得しました。進捗をリセットして、もう一度挑戦しますか？</p>
            <div class="modal-buttons">
                <button class="modal-button cancel">キャンセル</button>
                <button class="modal-button reset">リセット</button>
            </div>
        </div>
    </div>
    
    <div id="nextQuestionModal" class="modal">
            <div class="modal-content">
                <h2 class="modal-title">素晴らしい！</h2>
                <p>理解が深まったようですね！次の問題に進みますか？</p>
                <div class="modal-buttons">
                    <button id="modalCancelNextQuestion" class="modal-button cancel">まだ続ける</button>
                    <button id="modalConfirmNextQuestion" class="modal-button create">次の問題へ</button>
                </div>
            </div>
        </div>
    
    <div id="tosModal" class="modal">
        <div class="modal-content">
            <h2 class="modal-title">利用規約</h2>
            <div id="tosContent">
                <p class="mb-2">このサービスはAI（人工知能）を利用しています。</p>
                <p class="mb-2">Google社のGemini APIを利用しています。</p>
                <p class="mb-2">AIによる回答結果には、誤った情報が含まれる可能性があり、その正確性を保証するものではありません。</p>
                <p>当サービスのご利用により生じた、いかなる損害についても、当方は一切の責任を負いません。</p>
            </div>
            <div class="modal-buttons">
                <button id="tosAgreeButton" class="modal-button create">同意して利用を開始</button>
            </div>
        </div>
    </div>

    <div id="addToHomeScreenPopup" class="text-sm">
        <button id="closeAddToHomeScreen">&times;</button>
        <p class="font-bold mb-2">ホーム画面に追加してアプリとして使おう！</p>
        <p>ブラウザの共有ボタン <span id="iosShareIconContainer" class="inline-block align-middle h-5 w-5 -mt-1"></span> から「ホーム画面に追加」を選択してください。</p>
        <p class="text-xs mt-2 text-gray-500">アプリ版とブラウザ版で生成したクイズが同期しないため、生成する前にアプリ版を使用することをおすすめします。</p>
    </div>
    
    <div id="loadingModal" class="modal">
    <div class="modal-content" style="max-width: 300px; text-align: center; background-color: var(--bg-secondary);">
        <div class="loader"></div>
        <p class="mt-4 text-lg font-semibold">ファイルを処理中...</p>
        <p id="loadingStatus" class="text-sm" style="color: var(--text-secondary); min-height: 1.25rem;"></p>
    </div>
</div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const sidebar = document.getElementById('sidebar');
            const hamburgerButton = document.getElementById('hamburgerButton');
            const sidebarOverlay = document.getElementById('sidebarOverlay');
            const newProjectButton = document.getElementById('newProjectButton');
            const getStartedButton = document.getElementById('getStartedButton');
            const projectTitle = document.getElementById('projectTitle');
            const projectSettingsButton = document.getElementById('projectSettingsButton');
            const projectListEl = document.getElementById('projectList');
            
            const screens = {
                welcome: document.getElementById('welcomeScreen'),
                projectStart: document.getElementById('projectStartScreen'),
                generate: document.getElementById('generationScreen'),
                quiz: document.getElementById('quizScreen'),
                result: document.getElementById('resultScreen'),
                aiTutor: document.getElementById('aiTutorScreen'),
            };
            const settingsScreen = document.getElementById('settingsScreen');

            const generateQuizButton = document.getElementById('generateQuizButton');
            const generateNewQuizBtn = document.getElementById('generateNewQuizBtn');
            const backToProjectStartBtn = document.getElementById('backToProjectStartBtn');
            const promptText = document.getElementById('promptText');
            const promptLabel = document.getElementById('promptLabel');
            const questionType = document.getElementById('questionType');
            const genQuestionCount = document.getElementById('genQuestionCount');
            const autoGenreCheckbox = document.getElementById('autoGenreCheckbox');
            const generationError = document.getElementById('generationError');
            const generationWarning = document.getElementById('generationWarning');
            const quizSelect = document.getElementById('quizSelect');
            const startSelectedQuizButton = document.getElementById('startSelectedQuizButton');
            const fileDropArea = document.getElementById('fileDropArea');
            const fileUpload = document.getElementById('fileUpload');
            const filePreviewContainer = document.getElementById('filePreviewContainer');

            const generateTabButton = document.getElementById('generateTabButton');
            const importTabButton = document.getElementById('importTabButton');
            const generateProjectContainer = document.getElementById('generateProjectContainer');
            const importProjectContainer = document.getElementById('importProjectContainer');
            const importFileInput = document.getElementById('importFileInput');
            const importProjectButton = document.getElementById('importProjectButton');
            const importStatusMessage = document.getElementById('importStatusMessage');
            const importMasteryCheckbox = document.getElementById('importMasteryCheckbox');
            const exportProjectButton = document.getElementById('exportProjectButton');


            const newProjectModal = document.getElementById('newProjectModal');
            const newProjectNameInput = document.getElementById('newProjectNameInput');
            const modalCreateProjectButton = document.getElementById('modalCreateProjectButton');
            const modalCancelProjectButton = document.getElementById('modalCancelProjectButton');

            const renameProjectModal = document.getElementById('renameProjectModal');
            const renameProjectNameInput = document.getElementById('renameProjectNameInput');
            const modalSaveRenameButton = document.getElementById('modalSaveRenameButton');
            const modalCancelRenameButton = document.getElementById('modalCancelRenameButton');
            
            const nameQuizModal = document.getElementById('nameQuizModal');
            const newQuizNameInput = document.getElementById('newQuizNameInput');
            const modalCreateQuizButton = document.getElementById('modalCreateQuizButton');
            const modalCancelQuizButton = document.getElementById('modalCancelQuizButton');

            const interruptModal = document.getElementById('interruptModal');
            const modalConfirmInterrupt = document.getElementById('modalConfirmInterrupt');
            const modalCancelInterrupt = document.getElementById('modalCancelInterrupt');

            const deleteProjectModal = document.getElementById('deleteProjectModal');
            const deleteProjectName = document.getElementById('deleteProjectName');
            const modalConfirmDelete = document.getElementById('modalConfirmDelete');
            const modalCancelDelete = document.getElementById('modalCancelDelete');

            let questionTextElement = document.getElementById('questionText');
            let optionsGridElement = document.getElementById('optionsGrid');
            const quizTitleEl = document.getElementById('quizTitle');
            const questionImage = document.getElementById('questionImage');
            const longContentBox = document.getElementById('longContentBox');
            const submissionArea = document.getElementById('submissionArea');
            const feedbackMessageElement = document.getElementById('feedbackMessage');
            const feedbackResultElement = document.getElementById('feedbackResult');
            const explanationContentElement = document.getElementById('explanationContent');
            const explanationTextElement = explanationContentElement.querySelector('.explanation-text');
            const toggleExplanationButton = document.getElementById('toggleExplanationButton');
            const nextButton = document.getElementById('nextButton');
            
            const interruptButton = document.getElementById('interruptButton');

            const progressBarContainer = document.querySelector('.progress-container');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const finalScore = document.getElementById('finalScore');
            const scoreComment = document.getElementById('scoreComment');
            const confettiContainer = document.getElementById('confettiContainer');
            const restartQuizButton = document.getElementById('restartQuizButton');
            const backToProjectButton = document.getElementById('backToProjectButton');
            
            const darkModeToggle = document.getElementById('darkModeToggle');
            const themeColorCircles = document.querySelectorAll('.color-circle');
            const soundVolumeSlider = document.getElementById('soundVolumeSlider');
            const volumeStatus = document.getElementById('volumeStatus');
            const questionCountSelect = document.getElementById('questionCountSelect');
            const shuffleQuestionsToggle = document.getElementById('shuffleQuestionsToggle');
            const showProgressToggle = document.getElementById('showProgressToggle');
            const masteryModeToggle = document.getElementById('masteryModeToggle');
            const backToProjectFromSettings = document.getElementById('backToProjectFromSettings');
            const editQuizzesButton = document.getElementById('editQuizzesButton');

            const editQuizzesModal = document.getElementById('editQuizzesModal');
            const editQuizList = document.getElementById('editQuizList');
            const closeEditQuizModalButton = document.getElementById('closeEditQuizModalButton');
            
            const renameQuizInstanceModal = document.getElementById('renameQuizInstanceModal');
            const renameQuizNameInstanceInput = document.getElementById('renameQuizNameInstanceInput');

            const deleteQuizInstanceModal = document.getElementById('deleteQuizInstanceModal');
            const deleteQuizNameInstance = document.getElementById('deleteQuizNameInstance');
            const resetMasteryModal = document.getElementById('resetMasteryModal');
            const nextQuestionModal = document.getElementById('nextQuestionModal');
            const modalConfirmNextQuestion = document.getElementById('modalConfirmNextQuestion');
            const modalCancelNextQuestion = document.getElementById('modalCancelNextQuestion');

            const tosModal = document.getElementById('tosModal');
            const tosAgreeButton = document.getElementById('tosAgreeButton');
            const addToHomeScreenPopup = document.getElementById('addToHomeScreenPopup');
            const closeAddToHomeScreen = document.getElementById('closeAddToHomeScreen');

            const aiTutorButton = document.getElementById('aiTutorButton');
            const aiTutorActionsContainer = document.getElementById('aiTutorActionsContainer');
            const aiTutorQuestionText = document.getElementById('aiTutorQuestionText');
            const aiTutorChatLog = document.getElementById('aiTutorChatLog');
            const aiTutorInputForm = document.getElementById('aiTutorInputForm');
            const aiTutorInput = document.getElementById('aiTutorInput');
            const aiTutorSubmitButton = document.getElementById('aiTutorSubmitButton');
            const voiceInputButton = document.getElementById('voiceInputButton');
            const toggleOtherOptionsButton = document.getElementById('toggleOtherOptionsButton');
            const otherOptionsContainer = document.getElementById('otherOptionsContainer');

            let appState = {
                projects: [],
                settings: {
                    darkMode: false,
                    themeColor: 'default',
                    soundVolume: 75,
                    questionCount: 5,
                    shuffleQuestions: true,
                    showProgress: true,
                    masteryMode: false,
                }
            };
            let activeProjectId = null;
            let currentQuiz = null; 
            let confettiAnimationId;
            let tempGeneratedQuestions = null;
            let tempGeneratedImages = [];
            let uploadedFiles = [];
            let projectToEditId = null;
            let quizToEditId = null;
            let aiChatHistory = [];
            let speechRecognition;
            let isRecording = false;
            let aiTutorInteractionCount = 0;
            
            const sounds = {
                correct: new Tone.Synth({ volume: -2, oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination(),
                incorrect: new Tone.FMSynth({ volume: 4, harmonicity: 1.5, modulationIndex: 10, oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.01, release: 0.1 } }).toDestination(),
                click: new Tone.Synth({ volume: -5, oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 } }).toDestination(),
                fanfare: new Tone.PolySynth(Tone.Synth, { volume: 0 }).toDestination(),
                micOn: new Tone.Synth({ volume: -15, oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, release: 0.1 } }).toDestination(),
                micOff: new Tone.Synth({ volume: -15, oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, release: 0.2 } }).toDestination(),
            };
            
            // ★★★ 変更箇所 ★★★ START - 全ての関数を関数宣言に統一
            function updateVolume(level) {
                const numberLevel = Number(level);
                let db;
                if (numberLevel === 0) {
                    db = -Infinity;
                    volumeStatus.textContent = 'オフ';
                } else {
                    db = (numberLevel / 100) * 30 - 25;
                    volumeStatus.textContent = '';
                }
                
                sounds.correct.volume.value = db;
                sounds.click.volume.value = db - 4;
                sounds.fanfare.volume.value = db;
                sounds.incorrect.volume.value = db + 6;
                sounds.micOn.volume.value = db - 5;
                sounds.micOff.volume.value = db - 5;
                
                appState.settings.soundVolume = numberLevel;
            };

            async function playSound(type) {
                if (appState.settings.soundVolume === 0) return;
                if (Tone.context.state !== 'running') await Tone.start();
                const now = Tone.now();
                try {
                    switch (type) {
                        case 'correct': sounds.correct.triggerAttackRelease("C5", "8n", now); break;
                        case 'incorrect': sounds.incorrect.triggerAttackRelease("A2", "8n", now); break;
                        case 'click': sounds.click.triggerAttackRelease("C6", "16n", now); break;
                        case 'fanfare':
                            ["C5", "E5", "G5", "C6"].forEach((note, i) => {
                                sounds.fanfare.triggerAttackRelease(note, "8n", now + i * 0.15);
                            });
                            break;
                        case 'micOn': sounds.micOn.triggerAttackRelease("E5", "16n", now); break;
                        case 'micOff': sounds.micOff.triggerAttackRelease("C5", "16n", now); break;
                    }
                } catch (error) { console.error("Sound playback failed:", error); }
            }
            
            function saveState() {
                try {
                    // 通常の保存処理を試みる
                    const dataToSave = JSON.stringify(appState);
                    localStorage.setItem('qube_app_data', dataToSave);

                } catch (e) {
                    // 保存に失敗した場合の処理
                    console.error("Failed to save state:", e);

                    // iOSでよく発生する容量超過エラーかどうかを判定
                    if (e.name === 'QuotaExceededError') {
                        // ユーザーに分かりやすいメッセージで通知
                        alert(
                            'データの保存に失敗しました。\n\n' +
                            '以下の原因が考えられます：\n' +
                            '・Safariがプライベートブラウジングモードになっている\n' +
                            '・端末のストレージ空き容量が不足している\n' +
                            '・プロジェクトのデータサイズが大きすぎる\n\n' +
                            'プライベートブラウジングをオフにして、もう一度お試しください。'
                        );
                    } else {
                        // その他の予期せぬエラー
                        alert('予期せぬエラーにより、データの保存に失敗しました。');
                    }
                }
            };
            function loadState() {
                const savedData = localStorage.getItem('qube_app_data');
                if (savedData) {
                    const loadedState = JSON.parse(savedData);
                    appState.settings = { ...appState.settings, ...loadedState.settings };
                    appState.projects = loadedState.projects || [];

                    if (appState.projects) {
                        appState.projects.forEach(p => {
                            if (!p.mastery) p.mastery = {};
                            if (p.isPinned === undefined) p.isPinned = false;
                        });
                    }
                }
            };

            function adjustTitleFontSize(element, text) {
                 if (!element) return;
                
                 const defaultSize = window.innerWidth < 768 ? 1.25 : 1.875;
                 element.innerHTML = '';
                
                 if (!text || text === 'Qube') {
                     const img = document.createElement('img');
                     img.src = "iconsp.png";
                     img.alt = "Qube Logo";
                     img.className = "h-10 w-16 mx-auto";
                     img.onerror = function() {
                         this.style.display='none';
                         const span = document.createElement('span');
                         span.textContent = 'Qube';
                         element.appendChild(span);
                     };
                     element.appendChild(img);
                 } else {
                     element.textContent = text;
                     element.style.fontSize = `${defaultSize}rem`;
                 }
            };
            
            function updateProjectTitle(text) {
                if (screens.welcome.classList.contains('active')) {
                    adjustTitleFontSize(projectTitle, '学習を始めましょう！');
                } else if (screens.aiTutor.classList.contains('active')) {
                    adjustTitleFontSize(projectTitle, '🤖 AIチューター');
                } else {
                    adjustTitleFontSize(projectTitle, text || 'Qube');
                }
            };

            function switchScreen(screenName) {
                Object.values(screens).forEach(s => s.classList.remove('active'));
                if (screens[screenName]) screens[screenName].classList.add('active');
                
                const isQuizOrTutor = screenName === 'quiz' || screenName === 'aiTutor';
                hamburgerButton.classList.toggle('hidden', isQuizOrTutor);
                projectSettingsButton.classList.toggle('invisible', isQuizOrTutor || screenName === 'welcome' || screenName === 'generate');
                interruptButton.classList.toggle('hidden', !isQuizOrTutor);
                if(isQuizOrTutor) {
                    interruptButton.textContent = screenName === 'aiTutor' ? '終了' : '中断';
                }
                
                if (screenName === 'quiz') {
                    adjustTitleFontSize(quizTitleEl, currentQuiz?.name || "クイズ");
                } else {
                    const project = appState.projects.find(p => p.id === activeProjectId);
                    updateProjectTitle(project?.name || 'Qube');
                }
            };

            function toggleSidebar() {
                const isOpen = sidebar.classList.toggle('open');
                if (window.innerWidth < 768) {
                    sidebarOverlay.classList.toggle('active', isOpen);
                } else {
                    document.body.classList.toggle('sidebar-open-desktop', isOpen);
                }
            };
            
            function showNewProjectModal() {
                newProjectNameInput.value = `プロジェクト ${appState.projects.length + 1}`;
                newProjectModal.classList.add('show');
                newProjectNameInput.focus();
                newProjectNameInput.select();
            };

            function closeNewProjectModal() {
                newProjectModal.classList.remove('show');
            }
            
            function handleCreateProject() {
                const projectName = newProjectNameInput.value.trim();
                if (!projectName) {
                    newProjectNameInput.focus();
                    return;
                }
                const newProject = { 
                    id: `proj_${Date.now()}`, 
                    name: projectName, 
                    quizzes: [],
                    mastery: {},
                    lastPlayedQuizId: null,
                    isPinned: false
                };
                appState.projects.unshift(newProject);
                saveState();
                renderProjectList();
                setActiveProject(newProject.id);
                closeNewProjectModal();
                if(window.innerWidth < 768 && sidebar.classList.contains('open')) toggleSidebar();
            };

            function renderProjectList() {
                projectListEl.innerHTML = '';
                if (appState.projects.length === 0) {
                    projectListEl.innerHTML = '<p class="text-gray-400 p-2">まだプロジェクトがありません。</p>';
                    return;
                }
                
                const sortedProjects = [...appState.projects].sort((a, b) => (b.isPinned ? 1 : 0) - (a.isPinned ? 1 : 0));

                sortedProjects.forEach(p => {
                    const projectEl = document.createElement('div');
                    projectEl.className = `project-item ${p.id === activeProjectId ? 'active' : ''}`;
                    projectEl.dataset.projectId = p.id;
                    projectEl.draggable = true;

                    let pinIcon = '';
                    if (p.isPinned) {
                        pinIcon = `<span class="mr-2 flex-shrink-0">📌</span>`;
                    }

                    const nameEl = document.createElement('div');
                    nameEl.innerHTML = pinIcon + `<span class="flex-grow">${p.name}</span>`;
                    nameEl.className = 'project-name flex items-center';
                    
                    const menuBtn = document.createElement('button');
                    menuBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z" /></svg>`;
                    menuBtn.className = 'project-menu-btn';
                    
                    projectEl.appendChild(nameEl);
                    projectEl.appendChild(menuBtn);
                    projectListEl.appendChild(projectEl);

                    nameEl.addEventListener('click', () => {
                        setActiveProject(p.id);
                        if(window.innerWidth < 768) toggleSidebar();
                    });

                    menuBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showProjectMenu(p.id, e.currentTarget.parentElement);
                    });
                });
                addProjectDragDropListeners();
            };
            
            function showProjectMenu(projectId, projectItemElement) {
                document.querySelectorAll('.project-menu').forEach(m => m.remove());
                const project = appState.projects.find(p => p.id === projectId);
                if (!project) return;

                const pinActionText = project.isPinned ? 'ピンを外す' : 'ピン留めする';

                const menu = document.createElement('div');
                menu.className = 'project-menu';
                menu.innerHTML = `
                    <div class="project-menu-item" data-action="pin" data-project-id="${projectId}">${pinActionText}</div>
                    <div class="project-menu-item" data-action="rename" data-project-id="${projectId}">名前を変更</div>
                    <div class="project-menu-item" data-action="export" data-project-id="${projectId}">書き出す</div>
                    <div class="project-menu-item delete" data-action="delete" data-project-id="${projectId}">削除</div>
                `;
                projectItemElement.appendChild(menu);
                
                menu.classList.add('show');
                
                const closeMenu = (e) => {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.body.removeEventListener('click', closeMenu, true);
                    }
                };

                menu.addEventListener('click', (e) => {
                    const action = e.target.closest('.project-menu-item')?.dataset.action;
                    if (action === 'rename') showRenameProjectModal(projectId);
                    else if (action === 'delete') showDeleteProjectModal(projectId);
                    else if (action === 'pin') toggleProjectPin(projectId);
                    else if (action === 'export') handleExportProject(projectId);
                    menu.remove();
                    document.body.removeEventListener('click', closeMenu, true);
                });

                setTimeout(() => document.body.addEventListener('click', closeMenu, true), 0);
            };

            function toggleProjectPin(projectId) {
                const project = appState.projects.find(p => p.id === projectId);
                if (project) {
                    project.isPinned = !project.isPinned;
                    saveState();
                    renderProjectList();
                }
            };

            function showRenameProjectModal(projectId) {
                projectToEditId = projectId;
                const project = appState.projects.find(p => p.id === projectId);
                if (project) {
                    renameProjectNameInput.value = project.name;
                    renameProjectModal.classList.add('show');
                    renameProjectNameInput.focus();
                    renameProjectNameInput.select();
                }
            };

            function closeRenameProjectModal() {
                renameProjectModal.classList.remove('show');
                projectToEditId = null;
            };

            function handleRenameProject() {
                const newName = renameProjectNameInput.value.trim();
                if (!newName || !projectToEditId) return;
                const project = appState.projects.find(p => p.id === projectToEditId);
                if (project) {
                    project.name = newName;
                    saveState();
                    renderProjectList();
                    if (activeProjectId === projectToEditId) updateProjectTitle(newName);
                }
                closeRenameProjectModal();
            };

            function showDeleteProjectModal(projectId) {
                projectToEditId = projectId;
                const project = appState.projects.find(p => p.id === projectId);
                if(project) {
                    deleteProjectName.textContent = project.name;
                    deleteProjectModal.classList.add('show');
                }
            };
            
            function closeDeleteProjectModal() {
                deleteProjectModal.classList.remove('show');
                projectToEditId = null;
            };

            function handleDeleteProject() {
                if(!projectToEditId) return;
                appState.projects = appState.projects.filter(p => p.id !== projectToEditId);
                if(activeProjectId === projectToEditId) {
                    activeProjectId = null;
                    localStorage.removeItem('qube_lastActiveProjectId');
                    updateProjectTitle('Qube');
                    switchScreen('welcome');
                }
                saveState();
                renderProjectList();
                closeDeleteProjectModal();
            };

            function addProjectDragDropListeners() {
                let draggedItem = null;
                projectListEl.querySelectorAll('.project-item').forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        draggedItem = item;
                        setTimeout(() => item.classList.add('dragging'), 0);
                    });
                    item.addEventListener('dragend', () => {
                        setTimeout(() => {
                            if (draggedItem) draggedItem.classList.remove('dragging');
                            draggedItem = null;
                        }, 0);
                    });
                });
                projectListEl.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const afterElement = getDragAfterElement(projectListEl, e.clientY);
                    if (draggedItem) {
                        if (afterElement == null) projectListEl.appendChild(draggedItem);
                        else projectListEl.insertBefore(draggedItem, afterElement);
                    }
                });
                projectListEl.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const newOrderIds = Array.from(projectListEl.querySelectorAll('.project-item')).map(item => item.dataset.projectId);
                    appState.projects.sort((a, b) => newOrderIds.indexOf(a.id) - newOrderIds.indexOf(b.id));
                    saveState();
                    renderProjectList();
                });
            };

            function getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('.project-item:not(.dragging)')];
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
                    else return closest;
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            };

            function setActiveProject(projectId) {
                activeProjectId = projectId;
                localStorage.setItem('qube_lastActiveProjectId', projectId);
                resetUploadUI();
                promptText.value = '';
                const project = appState.projects.find(p => p.id === projectId);
                if (project) {
                    updateProjectTitle(project.name);
                    if (project.quizzes.length === 0) {
                        switchScreen('generate'); 
                        backToProjectStartBtn.style.display = 'none';
                    } else {
                        populateQuizSelect(project);
                        switchScreen('projectStart');
                    }
                }
                renderProjectList();
            };

            function populateQuizSelect(project) {
                quizSelect.innerHTML = '';
                if (project.quizzes.length === 0) {
                    const option = document.createElement('option');
                    option.textContent = '利用可能なクイズがありません';
                    option.disabled = true;
                    quizSelect.appendChild(option);
                    startSelectedQuizButton.disabled = true;
                    aiTutorButton.disabled = true;
                } else {
                    const requiredMasteryCount = appState.settings.masteryMode ? 2 : 1;
                    project.quizzes.forEach(quiz => {
                        const masteryData = (project.mastery && project.mastery[quiz.id]) ? project.mastery[quiz.id] : {};
                        const masteredCount = Object.values(masteryData).filter(count => count >= requiredMasteryCount).length;
                        const isFullyMastered = masteredCount === quiz.questions.length && quiz.questions.length > 0;
                        
                        const option = document.createElement('option');
                        option.value = quiz.id;
                        option.textContent = (isFullyMastered ? '✅ ' : '') + quiz.name;
                        quizSelect.appendChild(option);
                    });
                    startSelectedQuizButton.disabled = false;
                    aiTutorButton.disabled = false;
                    if (project.lastPlayedQuizId) {
                        quizSelect.value = project.lastPlayedQuizId;
                    }
                }
            };

            function shuffleArray(array) {
                const newArr = [...array];
                for (let i = newArr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
                }
                return newArr;
            };
            
            async function handleGenerateQuiz() {
                const buttonText = generateQuizButton.querySelector('.button-text');
                const spinner = generateQuizButton.querySelector('.spinner');
                generationError.classList.add('hidden');
                generationWarning.classList.add('hidden');
            
                if (promptText.value.trim() === '' && uploadedFiles.length === 0) {
                    generationError.textContent = 'クイズの元になる内容を入力またはアップロードしてください。';
                    generationError.classList.remove('hidden');
                    return;
                }
            
                const warningTimeout = setTimeout(() => {
                    generationWarning.textContent = '生成に時間がかかる可能性があります...';
                    generationWarning.classList.remove('hidden');
                }, 15000);
            
                buttonText.textContent = '生成準備中...';
                spinner.classList.remove('hidden');
                generateQuizButton.disabled = true;
                
                let payload;
            
                try {
                    // --- START: ファイル変換処理 ---
                    const processedFiles = [];
                    if (uploadedFiles.length > 0) {
                        const loadingModal = document.getElementById('loadingModal');
                        const loadingStatus = document.getElementById('loadingStatus');
                        loadingModal.classList.add('show');
                        
                        for (const file of uploadedFiles) {
                            if (file.isPdf) {
                                loadingStatus.textContent = `PDFを画像に変換中: ${file.name}`;
                                const pdf = await pdfjsLib.getDocument({ data: file.pdfData }).promise;
                                for (let i = 1; i <= pdf.numPages; i++) {
                                    loadingStatus.textContent = `PDFを画像に変換中... (${i}/${pdf.numPages}ページ)`;
                                    const page = await pdf.getPage(i);
                                    const viewport = page.getViewport({ scale: 1.5 });
                                    const canvas = document.createElement('canvas');
                                    canvas.height = viewport.height;
                                    canvas.width = viewport.width;
                                    await page.render({ canvasContext: canvas.getContext('2d'), viewport: viewport }).promise;
                                    processedFiles.push({
                                        mimeType: 'image/jpeg',
                                        content: canvas.toDataURL('image/jpeg', 0.8)
                                    });
                                }
                            } else {
                                processedFiles.push(file);
                            }
                        }
                        loadingModal.classList.remove('show');
                    }
                    // --- END: ファイル変換処理 ---
            
                    // APIリクエストの前に、処理済みの画像データを一時変数に保存します。
                    tempGeneratedImages = processedFiles.filter(f => f.mimeType && f.mimeType.startsWith('image/'));
            
                    buttonText.textContent = '生成中...';
            
                    const apiKey = "AIzaSyDBics-IMwGjNoh-2Rqj979DrinKEnyO1A";
                    const isAutoGenre = autoGenreCheckbox.checked;
                    const selectedType = questionType.value;
                    const numQuestions = genQuestionCount.value === 'all' ? '可能な限り多く' : `${genQuestionCount.value}問`;
                    
                    let basePrompt = `あなたは優秀なクイズ生成AIです。提供されたテキストや画像を分析し、以下の指示に従って質の高いクイズを${numQuestions}作成してください。
                
                    # 指示分析
                    - もし提供されたテキストが「〇〇についての問題を作って」のような指示形式であれば、その指示に従ってクイズを生成してください。
                    - もし提供されたテキストが「日本の首都は東京です」のような事実や文章であれば、その内容に基づいてクイズを生成してください。
                    - 指示自体を問題文にするのではなく、指示内容に沿った問題を作成してください。
                    
                    # 基本ルール
                    画像群がPDFの連続したページである可能性も考慮し、全体の文脈を理解して問題を作成してください。`;
            
                    if (isAutoGenre) {
                        basePrompt += `内容を複数の複数のジャンルに分け、各ジャンルごとに問題を作成してください。`;
                    }
                    
                    basePrompt += `各問題には、内容に最適な形式("multiple_choice", "multiple_select", "fill_in_the_blank", "sorting")をAIが判断して指定し、必ず詳細な解説を日本語で付けてください。
            
                    # 文章と設問の分離ルール (重要)
                    - 問題の前提となる長文、対話文、あるいは例文などがある場合は、その文章を long_content フィールドに格納してください。
                    - question フィールドには、「空欄に最も適切な語句を選びなさい」や「この文章の要点は何ですか？」といった、その文章に対する設問そのものを格納してください。
                    - このルールは特に、英文の空欄補充問題や読解問題で厳密に守ってください。
            
                    # JSON形式の厳守
                    - "answer"フィールドには、必ず"options"や"items"配列に含まれる選択肢の**テキストそのもの**を、配列形式で正確に格納してください。例: ["東京都"]
                    - "options"フィールドには、解答の選択肢となる文字列の配列を入れてください。選択肢の前に「A:」のような記号は不要です。`;
                    
                    if (selectedType !== 'auto_select') {
                        basePrompt += `\n# 問題形式の厳守\n全てのクイズの問題形式(JSONのtypeフィールド)は、必ず「${selectedType}」に統一してください。他の形式は絶対に使用しないでください。`;
                    }
                    
                    basePrompt += `生成される問題は、提供された情報源と完全に一致し、事実として正確でなければなりません。`;
                    
                    payload = {
                        contents: [{ role: "user", parts: [] }],
                        generationConfig: { responseMimeType: "application/json" }
                    };
                    
                    const parts = [{ text: basePrompt }];
                    if (promptText.value.trim()) {
                        parts.push({ text: `\n\n--- テキスト内容 ---\n${promptText.value}` });
                    }
                    
                    processedFiles.forEach(file => {
                        parts.push({
                            inlineData: {
                                mimeType: file.mimeType,
                                data: file.content.split(',')[1]
                            }
                        });
                    });
                    payload.contents[0].parts = parts;
                    
                    let itemSchema = {
                        type: "OBJECT",
                        properties: {
                            question: { type: "STRING" },
                            type: { type: "STRING" },
                            options: { type: "ARRAY", items: { type: "STRING" } },
                            items: { type: "ARRAY", items: { type: "STRING" } },
                            answer: { type: "ARRAY", items: { type: "STRING" } },
                            explanation: { type: "STRING" },
                            long_content: { type: "STRING" },
                            image_source: { type: "BOOLEAN" }
                        },
                        required: ["question", "type", "answer", "explanation"]
                    };
            
                    if (isAutoGenre) {
                        payload.generationConfig.responseSchema = {
                            type: "OBJECT",
                            properties: {
                                "genres": {
                                    type: "ARRAY",
                                    items: {
                                        type: "OBJECT",
                                        properties: {
                                            "genre_name": { type: "STRING" },
                                            "quizzes": { type: "ARRAY", items: itemSchema }
                                        },
                                        required: ["genre_name", "quizzes"]
                                    }
                                }
                            }
                        };
                    } else {
                        payload.generationConfig.responseSchema = {
                            type: "OBJECT",
                            properties: { "quizzes": { "type": "ARRAY", "items": itemSchema } }
                        };
                    }
                    
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
            
                    if (!response.ok) {
                        const errorBody = await response.text();
                        console.error("API Error Response:", errorBody);
                        throw new Error(`APIリクエストに失敗しました (ステータス: ${response.status})`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                        const generatedData = JSON.parse(result.candidates[0].content.parts[0].text);
                        
                        const processQuestions = (questions) => {
                            return questions.map(q => {
                                let processed = {...q};
                                if (!Array.isArray(processed.answer)) {
                                    processed.answer = [String(processed.answer)];
                                }
                                return processed;
                            });
                        };
            
                        if (isAutoGenre && generatedData.genres) {
                            const processedGenres = generatedData.genres.map(genre => ({
                                ...genre,
                                quizzes: processQuestions(genre.quizzes || [])
                            }));
                            handleAutoGenreResponse(processedGenres); 
                        } else if (generatedData.quizzes) {
                            tempGeneratedQuestions = processQuestions(generatedData.quizzes);
                            showNameQuizModal();
                        } else {
                            throw new Error("AIからの応答が期待された形式ではありません。");
                        }
                    } else {
                        console.error("Invalid API response structure:", result);
                        throw new Error("AIからの応答が無効、または空です。");
                    }
                } catch (error) {
                    // エラー時にも一時変数を確実にクリアします
                    tempGeneratedImages = [];
                    tempGeneratedQuestions = null;
                    console.error("Quiz generation failed:", error);
                    if(payload) {
                         console.error("Failed Payload:", JSON.stringify(payload, null, 2));
                    }
                    generationError.textContent = `クイズの生成に失敗しました: ${error.message}`;
                    generationError.classList.remove('hidden');
                } finally {
                    clearTimeout(warningTimeout);
                    generationWarning.classList.add('hidden');
                    buttonText.textContent = 'クイズを生成する';
                    spinner.classList.add('hidden');
                    generateQuizButton.disabled = false;
                }
            }

            function handleAutoGenreResponse(genres) {
                const project = appState.projects.find(p => p.id === activeProjectId);
                if (!project || !genres) return;
            
                genres.forEach(genre => {
                    if (genre.quizzes && genre.quizzes.length > 0) {
                        const newQuiz = {
                            id: `quiz_${Date.now()}_${Math.random()}`,
                            name: genre.genre_name,
                            createdAt: new Date().toISOString(),
                            questions: genre.quizzes,
                            // ★★★ 修正点: uploadedFiles を見るのではなく、処理済みの tempGeneratedImages を使う ★★★
                            images: tempGeneratedImages 
                        };
                        project.quizzes.push(newQuiz);
                        project.mastery[newQuiz.id] = {};
                    }
                });
            
                // ★★★ 追加: 処理完了後に一時変数をクリアする ★★★
                tempGeneratedImages = [];
                tempGeneratedQuestions = null; // 念のためこちらもクリア
            
                saveState();
                setActiveProject(activeProjectId);
            };

            function showNameQuizModal() {
                const project = appState.projects.find(p => p.id === activeProjectId);
                if (!project) return;
                newQuizNameInput.value = `クイズ ${project.quizzes.length + 1}`;
                nameQuizModal.classList.add('show');
                newQuizNameInput.focus();
                newQuizNameInput.select();
            };
            
            function closeNameQuizModal() {
                nameQuizModal.classList.remove('show');
                tempGeneratedQuestions = null;
                tempGeneratedImages = [];
            }

            function handleCreateQuiz() {
                const quizName = newQuizNameInput.value.trim();
                if (!quizName) {
                    newQuizNameInput.focus();
                    return;
                }
                const project = appState.projects.find(p => p.id === activeProjectId);

                if (project && tempGeneratedQuestions) {
                    const newQuiz = {
                        id: `quiz_${Date.now()}`,
                        name: quizName,
                        createdAt: new Date().toISOString(),
                        questions: tempGeneratedQuestions,
                        images: tempGeneratedImages
                    };
                    project.quizzes.push(newQuiz);
                    project.mastery[newQuiz.id] = {};
                    saveState();
                    tempGeneratedQuestions = null;
                    closeNameQuizModal();
                    setActiveProject(activeProjectId);
                } else {
                    alert("クイズの保存に失敗しました。AIからのデータが正しく取得できていない可能性があります。");
                    console.error("Quiz save failed: tempGeneratedQuestions is null or project not found.");
                }
            };

            function startQuiz(quiz) {
                if (sidebar.classList.contains('open')) {
                    toggleSidebar();
                }
                document.querySelectorAll('.project-menu').forEach(m => m.remove());
                if (!quiz || !quiz.questions || quiz.questions.length === 0) return;

                const project = appState.projects.find(p => p.id === activeProjectId);
                project.lastPlayedQuizId = quiz.id;
                saveState();
                
                const requiredMasteryCount = appState.settings.masteryMode ? 2 : 1;
                const masteryData = (project.mastery && project.mastery[quiz.id]) ? project.mastery[quiz.id] : {};
                
                let unmasteredIndices = quiz.questions
                    .map((_, index) => index)
                    .filter(index => (masteryData[index] || 0) < requiredMasteryCount);

                if (unmasteredIndices.length === 0) {
                     resetMasteryModal.classList.add('show');
                     resetMasteryModal.querySelector('.reset').onclick = () => {
                         project.mastery[quiz.id] = {};
                         saveState();
                         resetMasteryModal.classList.remove('show');
                         startQuiz(quiz);
                     };
                     resetMasteryModal.querySelector('.cancel').onclick = () => {
                         resetMasteryModal.classList.remove('show');
                     };
                     return;
                }
                
                const finalIndices = appState.settings.shuffleQuestions 
                    ? shuffleArray([...unmasteredIndices]) 
                    : unmasteredIndices;

                const questionLimit = appState.settings.questionCount;
                const questionsToAskIndices = finalIndices.slice(0, questionLimit);

                const questionsToAsk = questionsToAskIndices.map(index => quiz.questions[index]);
                
                currentQuiz = { 
                    ...quiz, 
                    questions: questionsToAsk,
                    originalIndices: questionsToAskIndices,
                    currentIndex: 0, 
                    score: 0, 
                    answeredQuestions: new Set() 
                };

                switchScreen('quiz');
                loadQuestion();
            };

            function loadQuestion() {
                feedbackMessageElement.style.visibility = 'hidden';
                feedbackMessageElement.classList.remove('correct-feedback', 'incorrect-feedback');
                feedbackResultElement.innerHTML = '';

                if (currentQuiz.currentIndex >= currentQuiz.questions.length) {
                    showQuizResult();
                    return;
                }

                const parent = optionsGridElement.parentNode;
                const newGrid = optionsGridElement.cloneNode(false);
                parent.replaceChild(newGrid, optionsGridElement);
                optionsGridElement = newGrid;

                const question = currentQuiz.questions[currentQuiz.currentIndex];
                questionTextElement.innerHTML = question.question;
                submissionArea.innerHTML = '';
                questionImage.classList.add('hidden');
                longContentBox.style.display = 'none';
                
                explanationContentElement.classList.remove('show');
                toggleExplanationButton.classList.add('hidden');
                toggleExplanationButton.textContent = '解説▼';


                if(question.image_source && currentQuiz.images && currentQuiz.images.length > 0) {
                    const imageForQuestion = currentQuiz.images.find(img => question.question.includes(img.name.split('.')[0]));
                    if(imageForQuestion) {
                        questionImage.src = imageForQuestion.content;
                        questionImage.classList.remove('hidden');
                    }
                }

                if (question.long_content) {
                    longContentBox.textContent = question.long_content;
                    longContentBox.style.display = 'block';
                }

                switch(question.type) {
                    case 'multiple_choice':
                        (appState.settings.shuffleQuestions ? shuffleArray([...question.options]) : [...question.options]).forEach(option => {
                            const button = document.createElement('button');
                            button.innerHTML = option;
                            button.classList.add('option-button');
                            button.dataset.option = option;
                            button.addEventListener('click', () => submitAnswer([option]));
                            optionsGridElement.appendChild(button);
                        });
                        break;
                    case 'multiple_select':
                        (appState.settings.shuffleQuestions ? shuffleArray([...question.options]) : [...question.options]).forEach(option => {
                            const button = document.createElement('button');
                            button.innerHTML = option;
                            button.classList.add('option-button');
                            button.dataset.option = option;
                            button.addEventListener('click', () => button.classList.toggle('selected'));
                            optionsGridElement.appendChild(button);
                        });
                        createSubmitButton();
                        break;
                    case 'fill_in_the_blank':
                        optionsGridElement.innerHTML = `<input type="text" id="fillInBlankInput" placeholder="答えを入力...">`;
                        createSubmitButton();
                        break;
                    case 'sorting':
                        optionsGridElement.classList.add('options-grid-full-width');
                        optionsGridElement.innerHTML = `
                            <div class="sorting-container">
                                <div>
                                    <h4 class="font-semibold mb-2 text-center">解答欄</h4>
                                    <div id="sortingTarget" class="sorting-box"></div>
                                </div>
                                <div>
                                    <h4 class="font-semibold mb-2 text-center">選択肢</h4>
                                    <div id="sortingSource" class="sorting-box"></div>
                                </div>
                            </div>`;
                        const sourceContainer = document.getElementById('sortingSource');
                        const shuffledItems = shuffleArray([...question.items]);
                        shuffledItems.forEach(itemText => {
                            const div = document.createElement('div');
                            div.innerHTML = itemText;
                            div.classList.add('option-button', 'sorting-item');
                            div.draggable = true;
                            sourceContainer.appendChild(div);
                        });
                        setupSortingInteractions();
                        createSubmitButton();
                        break;
                    default: 
                         optionsGridElement.innerHTML = `<p class="text-red-500">不明な問題形式です。</p>`;
                         currentQuiz.answeredQuestions.add(question.question);
                        break;
                }
                if(question.type !== 'sorting') {
                    optionsGridElement.classList.remove('options-grid-full-width');
                }

                updateProgressBar();
                updateNavigationButtons();
            };
            
            function createSubmitButton() {
                const submitBtn = document.createElement('button');
                submitBtn.textContent = '回答';
                submitBtn.classList.add('btn', 'btn-primary');
                submitBtn.addEventListener('click', () => {
                    const question = currentQuiz.questions[currentQuiz.currentIndex];
                    let answer;
                    switch(question.type) {
                        case 'multiple_select':
                            answer = Array.from(optionsGridElement.querySelectorAll('.option-button.selected')).map(btn => btn.dataset.option);
                            break;
                        case 'fill_in_the_blank':
                            answer = [document.getElementById('fillInBlankInput').value];
                            break;
                        case 'sorting':
                             answer = Array.from(document.getElementById('sortingTarget').querySelectorAll('.sorting-item')).map(item => item.textContent);
                             break;
                    }
                    submitAnswer(answer);
                });
                submissionArea.appendChild(submitBtn);
            }

            function submitAnswer(userAnswer) {
                const question = currentQuiz.questions[currentQuiz.currentIndex];
                if (currentQuiz.answeredQuestions.has(question.question)) return;

                let isCorrect = false;

                switch(question.type) {
                    case 'multiple_choice':
                    case 'fill_in_the_blank':
                        isCorrect = userAnswer[0].toLowerCase().trim() === question.answer[0].toLowerCase().trim();
                        break;
                    case 'multiple_select':
                        const sortedUserAnswer = [...userAnswer].sort();
                        const sortedCorrectAnswer = [...question.answer].sort();
                        isCorrect = JSON.stringify(sortedUserAnswer) === JSON.stringify(sortedCorrectAnswer);
                        break;
                    case 'sorting':
                        isCorrect = JSON.stringify(userAnswer) === JSON.stringify(question.items);
                        break;
                }
                
                showFeedback(isCorrect, question, userAnswer);
            };

            function showFeedback(isCorrect, question, userAnswer) {
                optionsGridElement.querySelectorAll('button, input, .sorting-item').forEach(el => {
                    el.disabled = true;
                });
                submissionArea.innerHTML = '';
                feedbackMessageElement.style.visibility = 'visible';
                const project = appState.projects.find(p => p.id === activeProjectId);
                const originalIndex = currentQuiz.originalIndices[currentQuiz.currentIndex];
                if (!project.mastery[currentQuiz.id]) {
                    project.mastery[currentQuiz.id] = {};
                }
                const currentMasteryCount = project.mastery[currentQuiz.id][originalIndex] || 0;


                if (isCorrect) {
                    playSound('correct');
                    feedbackResultElement.innerHTML = `<strong>正解！</strong>`;
                    feedbackMessageElement.classList.add('correct-feedback');
                    currentQuiz.score++;
                    project.mastery[currentQuiz.id][originalIndex] = currentMasteryCount + 1;

                } else {
                    playSound('incorrect');
                    let correctAnswerText;
                    if (question.type === 'sorting') {
                        correctAnswerText = question.items.join(' → ');
                    } else {
                        correctAnswerText = Array.isArray(question.answer) ? question.answer.join(', ') : question.answer;
                    }
                    feedbackResultElement.innerHTML = `<strong>不正解...</strong> 正解は「${correctAnswerText}」でした。`;
                    feedbackMessageElement.classList.add('incorrect-feedback');
                    project.mastery[currentQuiz.id][originalIndex] = 0;
                }
                saveState();
                
                currentQuiz.answeredQuestions.add(question.question);

                if (question.type === 'multiple_choice') {
                    optionsGridElement.querySelectorAll('.option-button').forEach(button => {
                        if (button.dataset.option === question.answer[0]) {
                            button.classList.add('correct');
                        } else if (button.dataset.option === userAnswer[0]) {
                            button.classList.add('incorrect');
                        }
                    });
                } else if (question.type === 'multiple_select') {
                    optionsGridElement.querySelectorAll('.option-button').forEach(button => {
                        const isCorrectAnswer = question.answer.includes(button.dataset.option);
                        const wasSelected = userAnswer.includes(button.dataset.option);
                        if (isCorrectAnswer) {
                            button.classList.add('correct');
                        } else if (wasSelected && !isCorrectAnswer) {
                            button.classList.add('incorrect');
                        }
                    });
                } else if(question.type === 'fill_in_the_blank') {
                    document.getElementById('fillInBlankInput').classList.add(isCorrect ? 'correct' : 'incorrect');
                }

                if (question.explanation) {
                    explanationTextElement.textContent = question.explanation;
                    toggleExplanationButton.classList.remove('hidden');
                }
                updateNavigationButtons();
            };
            
            function setupSortingInteractions() {
                const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
                const sourceContainer = document.getElementById('sortingSource');
                const targetContainer = document.getElementById('sortingTarget');

                const moveItem = (item) => {
                    if (item.parentElement === sourceContainer) {
                        targetContainer.appendChild(item);
                    } else {
                        sourceContainer.appendChild(item);
                    }
                };
                
                if (isTouchDevice) {
                    optionsGridElement.addEventListener('click', (e) => {
                        if (e.target.classList.contains('sorting-item')) {
                            moveItem(e.target);
                        }
                    });
                } else {
                    let draggedItem = null;
                    optionsGridElement.addEventListener('dragstart', (e) => {
                        if (e.target.classList.contains('sorting-item')) {
                            draggedItem = e.target;
                            setTimeout(() => e.target.classList.add('dragging'), 0);
                        }
                    });
                    optionsGridElement.addEventListener('dragend', (e) => {
                        if (draggedItem) {
                            draggedItem.classList.remove('dragging');
                            draggedItem = null;
                        }
                    });
                    [sourceContainer, targetContainer].forEach(container => {
                        container.addEventListener('dragover', e => {
                            e.preventDefault();
                            const afterElement = getDragAfterElement(container, e.clientY);
                            if (draggedItem) {
                                if (afterElement == null) {
                                    container.appendChild(draggedItem);
                                } else {
                                    container.insertBefore(draggedItem, afterElement);
                                }
                            }
                        });
                    });
                }
            };


            function updateNavigationButtons() {
                const question = currentQuiz.questions[currentQuiz.currentIndex];
                if (!question) {
                    nextButton.style.display = 'none';
                    return;
                }
                const isAnswered = currentQuiz.answeredQuestions.has(question.question);
                nextButton.style.display = isAnswered ? 'block' : 'none';
                nextButton.textContent = (currentQuiz.currentIndex === currentQuiz.questions.length - 1) ? '結果を見る' : '次の問題';
            };

            function updateProgressBar() {
                if (!appState.settings.showProgress) {
                    progressBarContainer.style.display = 'none';
                    progressText.style.display = 'none';
                    return;
                }
                progressBarContainer.style.display = 'block';
                progressText.style.display = 'block';
                const total = currentQuiz.questions.length;
                const current = currentQuiz.currentIndex + 1;
                const progress = total > 0 ? current / total : 0;
                progressBar.style.width = `${progress * 100}%`;
                progressText.textContent = `${Math.min(current, total)} / ${total} 問目`;
            };

            function showQuizResult() {
                switchScreen('result');
                const total = currentQuiz.questions.length;
                finalScore.textContent = `あなたのスコア: ${currentQuiz.score} / ${total}`;
                const percentage = total === 0 ? 0 : (currentQuiz.score / total) * 100;
                let comment = '';
                if (currentQuiz.score === total && total > 0) {
                    comment = '素晴らしい！全問正解です！🎉';
                    playSound('fanfare');
                    setTimeout(launchConfetti, 100);
                } else if (percentage >= 80) {
                    comment = 'よくできました！この調子で頑張りましょう！✨';
                } else if (percentage >= 50) {
                    comment = 'もう少しです！復習して、さらに上を目指しましょう！👍';
                } else {
                    comment = '頑張ろう！基礎をしっかり固めていきましょう！💪';
                }
                scoreComment.textContent = comment;
            };

            function launchConfetti() {
                if (confettiAnimationId) cancelAnimationFrame(confettiAnimationId);
                confettiContainer.innerHTML = '';
                const confettiPieces = [];
                const numConfetti = 100;
                const colors = ['#f43f5e', '#38bdf8', '#fbbf24', '#34d399', '#8b5cf6'];
                for (let i = 0; i < numConfetti; i++) {
                    const confetti = document.createElement('div');
                    confetti.classList.add('confetti');
                    confetti.style.backgroundColor = colors[i % colors.length];
                    confettiContainer.appendChild(confetti);
                    const piece = { element: confetti, x: confettiContainer.clientWidth / 2, y: confettiContainer.clientHeight, vx: (Math.random() - 0.5) * 10, vy: -Math.random() * 15 - 5, rotation: Math.random() * 360, rotationSpeed: (Math.random() - 0.5) * 20 };
                    confettiPieces.push(piece);
                }
                let startTime = null;
                function animate(timestamp) {
                    if (!startTime) startTime = timestamp;
                    let allOffScreen = true;
                    confettiPieces.forEach(p => {
                        p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.vx *= 0.99; p.rotation += p.rotationSpeed;
                        if (p.y < confettiContainer.clientHeight + 20) allOffScreen = false;
                        p.element.style.transform = `translate(${p.x}px, ${p.y}px) rotate(${p.rotation}deg)`;
                    });
                    if (allOffScreen && (timestamp - startTime) > 1000) {
                        cancelAnimationFrame(confettiAnimationId);
                    } else {
                        confettiAnimationId = requestAnimationFrame(animate);
                    }
                }
                confettiAnimationId = requestAnimationFrame(animate);
            };
            
            function hexToRgb(hex) {
                let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            function applyColors(themeName, isDark) {
                const root = document.documentElement;
                const themes = {
                     'default': { base: '#0ea5e9', hover: '#0284c7', darkBase: '#38bdf8', darkHover: '#0ea5e9' },
                     'red': { base: '#ef4444', hover: '#dc2626', darkBase: '#f87171', darkHover: '#ef4444' },
                     'green': { base: '#10b981', hover: '#059669', darkBase: '#4ade80', darkHover: '#10b981' },
                     'indigo': { base: '#6366f1', hover: '#4f46e5', darkBase: '#818cf8', darkHover: '#6366f1' }
                };
                const theme = themes[themeName] || themes.default;
                const accentColor = isDark ? theme.darkBase : theme.base;
                const accentHover = isDark ? theme.darkHover : theme.hover;
                const rgb = hexToRgb(accentColor);

                root.style.setProperty('--accent-primary', accentColor);
                root.style.setProperty('--accent-primary-hover', accentHover);
                root.style.setProperty('--accent-primary-shadow', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.3)`);
                root.style.setProperty('--progress-bar-bg', accentColor);
                
                if (isDark) {
                    root.style.setProperty('--themed-text-color', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.9)`);
                    root.style.setProperty('--bg-tertiary', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)`);
                    root.style.setProperty('--bg-welcome', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.15)`);
                } else {
                    root.style.setProperty('--themed-text-color', theme.hover);
                    root.style.setProperty('--bg-tertiary', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.1)`);
                    root.style.setProperty('--bg-welcome', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.05)`);
                }
            };
            
            function setDarkMode(isDark) {
                appState.settings.darkMode = isDark;
                document.body.classList.toggle('dark-mode', isDark);
                applyColors(appState.settings.themeColor, isDark);
                document.querySelector('meta[name="theme-color"]').content = isDark ? '#0f172a' : '#f0f9ff';
                saveState();
            };

            function setThemeColor(themeName) {
                appState.settings.themeColor = themeName;
                applyColors(themeName, appState.settings.darkMode);
                saveState();
            };

            // 既存のhandleFileSelect関数を、以下の内容でまるごと置き換えてください
async function handleFileSelect(files) {
    fileUpload.disabled = true;
    generationError.classList.add('hidden');

    // --- NEW: 処理中モーダルを表示 ---
    const loadingModal = document.getElementById('loadingModal');
    const loadingStatus = document.getElementById('loadingStatus');
    loadingStatus.textContent = '';
    loadingModal.classList.add('show');
    
    const filePromises = Array.from(files).map(file => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            
            if (file.type === 'application/pdf') {
                loadingStatus.textContent = `PDFを解析中: ${file.name}`;
                reader.onload = async (e) => {
                    try {
                        const pdfData = new Uint8Array(e.target.result);
                        const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
                        const numPages = pdf.numPages;

                        // --- MODIFIED: 最初の1ページだけを先に画像化 ---
                        const page = await pdf.getPage(1);
                        const viewport = page.getViewport({ scale: 1.5 });
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;
                        await page.render({ canvasContext: context, viewport: viewport }).promise;
                        
                        const firstPageDataUrl = canvas.toDataURL('image/jpeg', 0.8);

                        // --- MODIFIED: PDF専用のオブジェクトを作成して返す ---
                        const pdfResult = {
                            id: `file_${Date.now()}_${Math.random()}`,
                            isPdf: true,
                            name: file.name,
                            numPages: numPages,
                            firstPageDataUrl: firstPageDataUrl,
                            pdfData: pdfData // 残りのページを後で処理するために生のデータを保持
                        };
                        resolve([pdfResult]);

                    } catch (pdfError) {
                        reject(pdfError);
                    }
                };
                reader.readAsArrayBuffer(file);
            } else {
                // PDF以外のファイルの処理 (画像など)
                reader.onload = (e) => resolve([{ 
                    id: `file_${Date.now()}_${Math.random()}`,
                    isPdf: false,
                    name: file.name, 
                    content: e.target.result,
                    mimeType: file.type 
                }]);
                reader.onerror = (err) => reject(err);
                reader.readAsDataURL(file);
            }
        });
    });

    try {
        const results = await Promise.all(filePromises);
        const flattenedResults = results.flat(); 
        uploadedFiles.push(...flattenedResults);
        await updateUIAfterFileUpload(); 
    } catch (err) {
        console.error("File processing error:", err);
        generationError.textContent = `ファイルの処理に失敗しました: ${err.message}`;
        generationError.classList.remove('hidden');
    } finally {
        fileUpload.value = '';
        fileUpload.disabled = false;
        // --- NEW: 処理中モーダルを非表示 ---
        loadingModal.classList.remove('show');
    }
};

            // 既存のupdateUIAfterFileUpload関数を、以下の内容でまるごと置き換えてください
async function updateUIAfterFileUpload() {
    filePreviewContainer.innerHTML = '';
    for (const file of uploadedFiles) {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'file-preview-item';
        itemDiv.dataset.fileId = file.id; // --- MODIFIED: ユニークIDを付与 ---

        // --- NEW: PDFの場合の特別なプレビュー処理 ---
        if (file.isPdf) {
            itemDiv.style.alignItems = 'stretch'; // コンテナの幅を子要素に合わせる
            
            const pdfContainer = document.createElement('div');
            pdfContainer.style.display = 'flex';
            pdfContainer.style.flexDirection = 'column';
            pdfContainer.style.alignItems = 'center';

            const img = document.createElement('img');
            img.src = file.firstPageDataUrl;
            pdfContainer.appendChild(img);
            
            if (file.numPages > 1) {
                const summaryDiv = document.createElement('div');
                summaryDiv.style.textAlign = 'center';
                summaryDiv.style.marginTop = '8px';

                const summaryText = document.createElement('p');
                summaryText.className = 'text-gray-500 dark:text-gray-400 text-sm';
                summaryText.textContent = `...その他 ${file.numPages - 1} ページ`;

                const viewAllBtn = document.createElement('button');
                viewAllBtn.textContent = 'すべて見る';
                viewAllBtn.className = 'text-sm font-bold cursor-pointer';
                viewAllBtn.style.color = 'var(--accent-primary)';
                viewAllBtn.style.marginTop = '4px';
                viewAllBtn.style.background = 'none';
                viewAllBtn.style.border = 'none';
                viewAllBtn.style.padding = '0';

                summaryDiv.appendChild(summaryText);
                summaryDiv.appendChild(viewAllBtn);
                pdfContainer.appendChild(summaryDiv);
                
                // 「すべて見る」ボタンのクリックイベント
                viewAllBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    summaryDiv.innerHTML = '<p class="text-sm">画像を生成中...</p>';
                    
                    try {
                        const pdf = await pdfjsLib.getDocument({ data: file.pdfData }).promise;
                        for (let i = 2; i <= file.numPages; i++) { // 2ページ目から処理
                            const page = await pdf.getPage(i);
                            const viewport = page.getViewport({ scale: 1.5 });
                            const canvas = document.createElement('canvas');
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;
                            await page.render({ canvasContext: canvas.getContext('2d'), viewport: viewport }).promise;
                            
                            const newImg = document.createElement('img');
                            newImg.src = canvas.toDataURL('image/jpeg', 0.8);
                            newImg.style.marginTop = '8px';
                            pdfContainer.appendChild(newImg);
                        }
                        summaryDiv.remove(); // 処理が終わったらサマリーを消す
                    } catch (err) {
                        summaryDiv.innerHTML = '<p class="text-sm text-red-500">エラー</p>';
                        console.error("Error rendering PDF pages:", err);
                    }
                });
            }
            itemDiv.appendChild(pdfContainer);

        } else if (file.mimeType.startsWith('image/')) {
            const img = document.createElement('img');
            img.src = file.content;
            itemDiv.appendChild(img);
        } else {
            const icon = document.createElement('div');
            icon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>`;
            itemDiv.appendChild(icon);
        }

        const p = document.createElement('p');
        p.className = 'file-name';
        p.textContent = file.name;
        itemDiv.appendChild(p);
        
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-file-btn';
        removeBtn.innerHTML = '&times;';
        removeBtn.onclick = (e) => {
            e.stopPropagation();
            // --- MODIFIED: ユニークIDでファイルを検索して削除 ---
            const fileIdToRemove = itemDiv.dataset.fileId; 
            const fileIndex = uploadedFiles.findIndex(f => f.id === fileIdToRemove);
            if(fileIndex > -1){
                uploadedFiles.splice(fileIndex, 1);
            }
            updateUIAfterFileUpload();
        };
        itemDiv.appendChild(removeBtn);
        filePreviewContainer.appendChild(itemDiv);
    }

    if (uploadedFiles.length > 0) {
        promptLabel.textContent = 'アップロードしたファイルへの追加指示 (任意)';
        promptText.placeholder = '例: この内容について5問作成してください。';
    } else {
        resetUploadUI();
    }
};

            function resetUploadUI() {
                uploadedFiles = [];
                filePreviewContainer.innerHTML = '';
                fileUpload.value = ''; 
                promptLabel.textContent = 'クイズにしたい内容（プロンプト）';
                promptText.placeholder = '例:「英語の長文問題を作成してください。中学レベルで、ポスターから内容を…」　または　「日本の首都は東京です。海なし県は…」';
            };
            
            async function handleExportProject(projectId) {
                const projectToExport = appState.projects.find(p => p.id === projectId);
                if (!projectToExport) {
                    alert('エクスポート対象のプロジェクトが見つかりません。');
                    return;
                }

                const exportableProject = JSON.parse(JSON.stringify(projectToExport));
                delete exportableProject.isPinned;
                delete exportableProject.lastPlayedQuizId;

                const projectJson = JSON.stringify(exportableProject);
                const blob = new Blob([projectJson], { type: 'text/plain' });
                const fileName = `${projectToExport.name}.txt`;
                const file = new File([blob], fileName, { type: 'text/plain' });

                if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                    try {
                        await navigator.share({
                            title: projectToExport.name,
                            text: `このファイルをQubeで読み込んで、友達が作った「${projectToExport.name}」に挑戦してみよう！`,
                            files: [file],
                        });
                    } catch (error) {
                        console.log('共有がキャンセルされたか、失敗しました:', error);
                    }
                } else {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            };

            function handleImportProject() {
                const file = importFileInput.files[0];
                importStatusMessage.textContent = '';

                if (!file) {
                    importStatusMessage.textContent = 'ファイルを選択してください。';
                    importStatusMessage.style.color = 'red';
                    return;
                }

                const reader = new FileReader();

                reader.onload = (e) => {
                    try {
                        const importedText = e.target.result;
                        if (!importedText) {
                            throw new Error('ファイルが空か、読み込みに失敗しました。');
                        }
                        const importedProjectData = JSON.parse(importedText);

                        if (typeof importedProjectData.name !== 'string' || !Array.isArray(importedProjectData.quizzes) || typeof importedProjectData.mastery !== 'object') {
                            throw new Error('Qubeの有効なプロジェクトファイルではありません。');
                        }

                        const activeProject = appState.projects.find(p => p.id === activeProjectId);
                        if (!activeProject) {
                            throw new Error("読み込み先のプロジェクトが見つかりません。");
                        }

                        if (activeProject.quizzes.length > 0) {
                            // 既存クイズあり：マージ
                            activeProject.quizzes.push(...(importedProjectData.quizzes || []));
                            if (importMasteryCheckbox.checked) {
                                  Object.assign(activeProject.mastery, importedProjectData.mastery || {});
                               }
                            if (importedProjectData.images) {
                                activeProject.images = [...(activeProject.images || []), ...importedProjectData.images];
                            }
                            importStatusMessage.textContent = `「${activeProject.name}」にクイズを追加しました。`;
                            importStatusMessage.style.color = 'green';
                        } else {
                            // 既存クイズなし：置き換え
                            activeProject.name = importedProjectData.name;
                            activeProject.quizzes = importedProjectData.quizzes || [];
                            if (importMasteryCheckbox.checked) {
                                   activeProject.mastery = importedProjectData.mastery || {};
                               } else {
                                   activeProject.mastery = {};
                               }
                            activeProject.images = importedProjectData.images || [];
                            importStatusMessage.style.color = 'green';
                        }

                        saveState();
                        renderProjectList();

                        // 対策②：データの保存とリストの描画が完了した「後」に画面遷移を実行
                        setTimeout(() => {
                            setActiveProject(activeProject.id);
                        }, 0);

                    } catch (error) {
                        console.error("Import failed:", error);
                        importStatusMessage.textContent = `読み込みに失敗しました: ${error.message}`;
                        importStatusMessage.style.color = 'red';
                    } finally {
                        // ★★★ 対策①：ファイルの読み込みが全て完了してからリセット ★★★
                        // これで2回目以降のファイル選択も可能になる
                        importFileInput.value = '';
                    }
                };

                reader.onerror = () => {
                    importStatusMessage.textContent = 'ファイルの読み込み中にエラーが発生しました。';
                    importStatusMessage.style.color = 'red';
                    // エラー時にもリセットを試みる
                    importFileInput.value = '';
                };

                // 読み込み処理を開始
                reader.readAsText(file);
            };
            function showEditQuizzesModal() {
                const project = appState.projects.find(p => p.id === activeProjectId);
                if (!project) return;

                editQuizList.innerHTML = '';
                if (project.quizzes.length === 0) {
                    editQuizList.innerHTML = '<p class="text-gray-400 p-2">このプロジェクトにはまだクイズがありません。</p>';
                } else {
                    project.quizzes.forEach(quiz => {
                        const quizEl = document.createElement('div');
                        quizEl.className = 'project-item';
                        quizEl.draggable = true;
                        quizEl.dataset.quizId = quiz.id;
                        quizEl.innerHTML = `
                            <span class="drag-handle">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400 pointer-events-none" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
                            </span>
                            <div class="project-name">${quiz.name}</div>
                            <button class="project-menu-btn" data-action="rename" data-quiz-id="${quiz.id}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 pointer-events-none" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-11.212 11.212-3.536.354.354-3.536L13.586 3.586z" /></svg>
                            </button>
                            <button class="project-menu-btn text-red-500" data-action="delete" data-quiz-id="${quiz.id}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 pointer-events-none" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
                            </button>
                        `;
                        editQuizList.appendChild(quizEl);
                    });
                    addQuizDragDropListeners();
                }
                editQuizzesModal.classList.add('show');
            };

            function updateQuizOrder() {
                const project = appState.projects.find(p => p.id === activeProjectId);
                if (!project) return;
                const newOrderIds = Array.from(editQuizList.querySelectorAll('.project-item')).map(item => item.dataset.quizId);
                project.quizzes.sort((a, b) => newOrderIds.indexOf(a.id) - newOrderIds.indexOf(b.id));
                saveState();
                populateQuizSelect(project);
            };

            function addQuizDragDropListeners() {
                let draggedItem = null;

                editQuizList.querySelectorAll('.project-item').forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        draggedItem = item;
                        setTimeout(() => item.classList.add('dragging'), 0);
                    });
                    item.addEventListener('dragend', () => {
                        if (draggedItem) draggedItem.classList.remove('dragging');
                        draggedItem = null;
                    });
                });
                editQuizList.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const afterElement = getDragAfterElement(editQuizList, e.clientY);
                    if (draggedItem) {
                        if (afterElement == null) editQuizList.appendChild(draggedItem);
                        else editQuizList.insertBefore(draggedItem, afterElement);
                    }
                });
                editQuizList.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (!draggedItem) return;
                    updateQuizOrder();
                });

                let touchDraggedItem = null;
                const touchStart = (e) => {
                    const handle = e.target.closest('.drag-handle');
                    if (!handle) return;
                    e.preventDefault();
                    touchDraggedItem = handle.closest('.project-item');
                    touchDraggedItem.classList.add('dragging');
                    document.addEventListener('touchmove', touchMove, { passive: false });
                    document.addEventListener('touchend', touchEnd, { once: true });
                };
                const touchMove = (e) => {
                    if (!touchDraggedItem) return;
                    e.preventDefault();
                    const y = e.touches[0].clientY;
                    const afterElement = getDragAfterElement(editQuizList, y);
                    if (afterElement == null) editQuizList.appendChild(touchDraggedItem);
                    else editQuizList.insertBefore(touchDraggedItem, afterElement);
                };
                const touchEnd = () => {
                    if (!touchDraggedItem) return;
                    touchDraggedItem.classList.remove('dragging');
                    touchDraggedItem = null;
                    updateQuizOrder();
                    document.removeEventListener('touchmove', touchMove);
                };
                
                editQuizList.removeEventListener('touchstart', touchStart);
                editQuizList.addEventListener('touchstart', touchStart, { passive: false });
            };

            function handleQuizEditActions(e) {
                const button = e.target.closest('button');
                if (!button) return;
                
                const action = button.dataset.action;
                const id = button.dataset.quizId;
                if (!action || !id) return;

                quizToEditId = id;
                const project = appState.projects.find(p => p.id === activeProjectId);
                const quiz = project?.quizzes.find(q => q.id === quizToEditId);
                if (!quiz) return;

                if (action === 'rename') {
                    renameQuizNameInstanceInput.value = quiz.name;
                    renameQuizInstanceModal.classList.add('show');
                    renameQuizNameInstanceInput.focus();
                    renameQuizNameInstanceInput.select();
                } else if (action === 'delete') {
                    deleteQuizNameInstance.textContent = quiz.name;
                    deleteQuizInstanceModal.classList.add('show');
                }
            };

            function handleRenameQuiz() {
                const newName = renameQuizNameInstanceInput.value.trim();
                const project = appState.projects.find(p => p.id === activeProjectId);
                const quiz = project?.quizzes.find(q => q.id === quizToEditId);
                if (newName && quiz) {
                    quiz.name = newName;
                    saveState();
                    showEditQuizzesModal();
                    populateQuizSelect(project);
                }
                renameQuizInstanceModal.classList.remove('show');
                quizToEditId = null;
            };

            function handleDeleteQuiz() {
                const project = appState.projects.find(p => p.id === activeProjectId);
                if (project && quizToEditId) {
                    project.quizzes = project.quizzes.filter(q => q.id !== quizToEditId);
                    delete project.mastery[quizToEditId];
                    saveState();
                    
                    if (project.quizzes.length === 0) {
                        editQuizzesModal.classList.remove('show');
                        setActiveProject(project.id);
                    } else {
                        showEditQuizzesModal();
                        populateQuizSelect(project);
                    }
                }
                deleteQuizInstanceModal.classList.remove('show');
                quizToEditId = null;
            };

            async function startAiTutorMode() {
                if (Tone.context.state !== 'running') await Tone.start();
                playSound('click');

                const project = appState.projects.find(p => p.id === activeProjectId);
                const selectedQuizId = quizSelect.value;
                const quiz = project?.quizzes.find(q => q.id === selectedQuizId);

                if (!quiz || quiz.questions.length === 0) {
                    alert("AIチューターを開始するには、問題を含むクイズを選択してください。");
                    return;
                }

                const question = quiz.questions[Math.floor(Math.random() * quiz.questions.length)];
                
                switchScreen('aiTutor');
                aiTutorChatLog.innerHTML = '';
                aiTutorInput.value = '';
                aiTutorSubmitButton.disabled = false;
                
                aiTutorInteractionCount = 0;
                aiTutorActionsContainer.innerHTML = '';
                aiTutorActionsContainer.classList.add('hidden');

                aiTutorQuestionText.innerHTML = `
                    <b>問題:</b> ${question.question}<br>
                    <b>正解:</b> <span class="correct-answer">${question.answer.join(', ')}</span>
                `;
                
                const otherOptions = (question.options || question.items || []).filter(opt => !question.answer.includes(opt));
                otherOptionsContainer.innerHTML = `不正解の選択肢: ${otherOptions.join(', ')}`;
                otherOptionsContainer.style.display = 'none';
                toggleOtherOptionsButton.textContent = '他の選択肢を見る▼';

                const initialPrompt = `あなたは、親しみやすく、常に励ましてくれる優秀でプロの学習のチューターです。かつ、あなたは常に正しい事実に基づき、間違ったことを教えないことを意識してください。
                    生徒がなぜその答えが正しいのかを自分の言葉で説明するのを手伝ってください。
                    決して答えを直接教えず、ソクラテス式問答法のように、生徒の思考を促す質問をしてください。
                    生徒の回答を分析し、褒めながら、さらに深い理解へと導くための追加の質問を生成してください。
                    生徒の説明が間違っている場合は、決してその間違いを肯定してはいけません。まず「惜しい！とても良い視点ですが、少しだけ違うかもしれません」のように、一度受け止めてから優しく間違いであることを伝えてください。その後、どこが違うのかを考えさせるような質問をして、正しい理解に導いてあげてください。
                    応答は常に短く、全体で5〜10文程度の簡潔な文章にして、一度に多くのことを説明するのではなく、一つずつ段階的に進めてください。
                    重要なキーワードは「**太字**」で強調し、必要に応じて箇条書き（リスト）を使い、情報を整理して見やすくしてください。
                    文脈に合ったポジティブな絵文字（例: ✨, 👍, 🎉, 💡）を文末に添えてください。思考を促す質問と解説のように、話の区切りでは改行を適切に入れてください。
                    生徒が完全に行き詰まった場合にのみ、少しだけヒントを与えてください。
                    常に日本語で応答してください。
                    生徒の理解が十分に深まったと判断した場合、最後に「だいぶ理解が深まったね！ほかの問題についても考えてみよう！」のようなまとめの言葉をかけてください。そのまとめの言葉の直後に、必ず特別な合図として \`[NEXT_QUESTION_TRIGGER]\` という文字列を応答に含めてください。
                    
                    【問題】: ${question.question}
                    【選択肢】: ${(question.options || question.items).join(', ')}
                    【正解】: ${question.answer.join(', ')}
                    ---
                    さあ、始めましょう！この問題の正解が「${question.answer.join(', ')}」になる理由を、あなたの言葉で説明してみてください。`;
                
                aiChatHistory = [{ role: "user", parts: [{ text: initialPrompt }] }];
                
                appendMessageToChat(`こんにちは！AIチューターです。一緒に頑張りましょう！💪<br>この問題の正解が「${question.answer.join(', ')}」になる理由を、あなたの言葉で説明してみてください。`, 'ai');
            };

            function appendMessageToChat(text, sender) {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('chat-message', sender);
                const formattedText = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                messageDiv.innerHTML = formattedText;
                aiTutorChatLog.appendChild(messageDiv);
                aiTutorChatLog.scrollTop = aiTutorChatLog.scrollHeight;
            };

            async function handleAiTutorSubmit(event) {
                event.preventDefault();
                const userInput = aiTutorInput.value.trim();
                if (!userInput) return;

                appendMessageToChat(userInput, 'user');
                aiTutorInput.value = '';
                aiTutorSubmitButton.disabled = true;

                const loadingIndicator = document.createElement('div');
                loadingIndicator.classList.add('chat-message', 'ai', 'loading');
                loadingIndicator.innerHTML = '<div class="dot-flashing"></div>';
                aiTutorChatLog.appendChild(loadingIndicator);
                aiTutorChatLog.scrollTop = aiTutorChatLog.scrollHeight;

                try {
                    aiChatHistory.push({ role: "user", parts: [{ text: userInput }] });
                    
                    const payload = { contents: aiChatHistory };
                    
                    // ★★★ 変更箇所 1/2: ここにあなたのAPIキーを設定 ★★★
                    const apiKey = "AIzaSyDBics-IMwGjNoh-2Rqj979DrinKEnyO1A";

                    if (!apiKey || apiKey === "ここにあなたのGoogle AI APIキーを貼り付け") {
                        throw new Error("APIキーが設定されていません。");
                    }
                    
                    // ★★★ 変更箇所 2/2: モデル名をAPIキー必須のものに戻す ★★★
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                         const errorBody = await response.json();
                         throw new Error(`APIエラー: ${errorBody.error.message}`);
                    }

                    const result = await response.json();
                    
                    aiTutorChatLog.removeChild(loadingIndicator);

                    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                        const aiResponse = result.candidates[0].content.parts[0].text;
                         if (aiResponse.includes('[NEXT_QUESTION_TRIGGER]')) {
                            aiResponse = aiResponse.replace('[NEXT_QUESTION_TRIGGER]', '').trim();
                            const nextQuestionModal = document.getElementById('nextQuestionModal');
                            nextQuestionModal.classList.add('show');
                        }
                        appendMessageToChat(aiResponse.replace(/\n/g, '<br>'), 'ai');
                        aiChatHistory.push({ role: "model", parts: [{ text: aiResponse }] });
                        
                        aiTutorInteractionCount++;
                        if (aiTutorInteractionCount >= 2) {
                            const changeQuestionBtn = document.createElement('button');
                            changeQuestionBtn.textContent = '問題を変える';
                            changeQuestionBtn.className = 'btn btn-sm';
                            changeQuestionBtn.style.backgroundColor = 'var(--button-bg-default)';
                            changeQuestionBtn.style.color = 'var(--button-text-default)';
                            changeQuestionBtn.style.border = '1px solid var(--border-color)';
                            changeQuestionBtn.onclick = () => startAiTutorMode();

                            aiTutorActionsContainer.innerHTML = '';
                            aiTutorActionsContainer.appendChild(changeQuestionBtn);
                            aiTutorActionsContainer.classList.remove('hidden');
                        }

                    } else {
                        // AIからの応答が空、または形式が不正な場合
                        throw new Error("AIから有効な応答がありませんでした。");
                    }
                } catch (error) {
                    console.error("AI Tutor Error:", error);
                    aiTutorChatLog.removeChild(loadingIndicator);
                    appendMessageToChat(`エラーが発生しました: ${error.message}`, 'ai');
                } finally {
                    aiTutorSubmitButton.disabled = false;
                    aiTutorInput.focus();
                }
            };
            modalConfirmNextQuestion.addEventListener('click', () => {
                nextQuestionModal.classList.remove('show');
                startAiTutorMode(); 
            });

            modalCancelNextQuestion.addEventListener('click', () => {
                nextQuestionModal.classList.remove('show');
            });
            
            function setupSpeechRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (SpeechRecognition) {
                    speechRecognition = new SpeechRecognition();
                    speechRecognition.lang = 'ja-JP';
                    speechRecognition.interimResults = false;
                    speechRecognition.maxAlternatives = 1;

                    speechRecognition.onstart = () => {
                        isRecording = true;
                        voiceInputButton.classList.add('recording');
                        playSound('micOn');
                    };

                    speechRecognition.onend = () => {
                        isRecording = false;
                        voiceInputButton.classList.remove('recording');
                        playSound('micOff');
                    };

                    speechRecognition.onresult = (event) => {
                        const speechResult = event.results[0][0].transcript;
                        aiTutorInput.value = speechResult;
                        aiTutorInputForm.dispatchEvent(new Event('submit'));
                    };

                    speechRecognition.onerror = (event) => {
                        console.error('Speech recognition error', event.error);
                        isRecording = false;
                        voiceInputButton.classList.remove('recording');
                    };
                } else {
                    voiceInputButton.style.display = 'none';
                }
            };

            function init() {
                const splashScreen = document.getElementById('splashScreen');
                
                loadState();
                
                const { settings } = appState;
                setDarkMode(settings.darkMode);
                darkModeToggle.checked = settings.darkMode;
                
                themeColorCircles.forEach(c => c.classList.remove('selected'));
                document.querySelector(`.color-circle[data-theme="${settings.themeColor}"]`)?.classList.add('selected');
                
                soundVolumeSlider.value = settings.soundVolume;
                updateVolume(settings.soundVolume);

                questionCountSelect.value = settings.questionCount;
                shuffleQuestionsToggle.checked = settings.shuffleQuestions;
                showProgressToggle.checked = settings.showProgress;
                masteryModeToggle.checked = settings.masteryMode;

                const lastActiveProjectId = localStorage.getItem('qube_lastActiveProjectId');
                const projectExists = appState.projects.some(p => p.id === lastActiveProjectId);
                if (lastActiveProjectId && projectExists) {
                    setActiveProject(lastActiveProjectId);
                } else if (appState.projects.length > 0) {
                    setActiveProject(appState.projects[0].id);
                }
                else {
                    switchScreen('welcome');
                }
                renderProjectList();
                setupSpeechRecognition();
                
                setTimeout(() => {
                    splashScreen.classList.add('hidden');
                    splashScreen.addEventListener('transitionend', () => {
                        splashScreen.style.display = 'none';
                    }, { once: true });
                }, 1500);

                if (!localStorage.getItem('qube_tos_agreed')) {
                    tosModal.classList.add('show');
                }
                
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                const isInStandaloneMode = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;

                if (isIOS && !isInStandaloneMode && !localStorage.getItem('qube_add_to_home_screen_dismissed')) {
                    const iosShareIconContainer = document.getElementById('iosShareIconContainer');
                    iosShareIconContainer.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>`;
                    setTimeout(() => {
                        addToHomeScreenPopup.style.display = 'block';
                    }, 5000);
                }
                
                if ('serviceWorker' in navigator) {
                    window.addEventListener('load', () => {
                        navigator.serviceWorker.register('/sw.js').then(registration => {
                            console.log('ServiceWorker registration successful with scope: ', registration.scope);
                        }).catch(error => {
                            console.log('ServiceWorker registration failed: ', error);
                        });
                    });
                }
            };
            // ★★★ 変更箇所 ★★★ END

            // --- Event Listeners ---
            hamburgerButton.addEventListener('click', toggleSidebar);
            sidebarOverlay.addEventListener('click', toggleSidebar);
            newProjectButton.addEventListener('click', showNewProjectModal);
            getStartedButton.addEventListener('click', showNewProjectModal);
            modalCreateProjectButton.addEventListener('click', handleCreateProject);
            modalCancelProjectButton.addEventListener('click', closeNewProjectModal);
            newProjectModal.addEventListener('click', (e) => { if (e.target === newProjectModal) closeNewProjectModal(); });
            newProjectNameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleCreateProject(); });

            modalSaveRenameButton.addEventListener('click', handleRenameProject);
            modalCancelRenameButton.addEventListener('click', closeRenameProjectModal);
            renameProjectModal.addEventListener('click', (e) => { if (e.target === renameProjectModal) closeRenameProjectModal(); });
            renameProjectNameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleRenameProject(); });
            
            generateNewQuizBtn.addEventListener('click', () => {
                const project = appState.projects.find(p => p.id === activeProjectId);
                if (project && project.quizzes.length === 0) {
                    backToProjectStartBtn.style.display = 'none';
                } else {
                    backToProjectStartBtn.style.display = 'block';
                }
                resetUploadUI();
                promptText.value = '';
                switchScreen('generate');
            });
            backToProjectStartBtn.addEventListener('click', () => setActiveProject(activeProjectId));
            generateQuizButton.addEventListener('click', handleGenerateQuiz);

            startSelectedQuizButton.addEventListener('click', () => {
                const selectedQuizId = quizSelect.value;
                const project = appState.projects.find(p => p.id === activeProjectId);
                if (project) {
                    const quizToStart = project.quizzes.find(q => q.id === selectedQuizId);
                    if (quizToStart) startQuiz(quizToStart);
                }
            });

            fileDropArea.addEventListener('click', () => fileUpload.click());
            fileUpload.addEventListener('change', (e) => handleFileSelect(e.target.files));
            fileDropArea.addEventListener('dragover', (e) => { e.preventDefault(); fileDropArea.classList.add('dragover'); });
            fileDropArea.addEventListener('dragleave', () => fileDropArea.classList.remove('dragover'));
            fileDropArea.addEventListener('drop', (e) => { e.preventDefault(); fileDropArea.classList.remove('dragover'); handleFileSelect(e.dataTransfer.files); });

            modalCreateQuizButton.addEventListener('click', handleCreateQuiz);
            modalCancelQuizButton.addEventListener('click', closeNameQuizModal);
            newQuizNameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleCreateQuiz(); });

            interruptButton.addEventListener('click', () => {
                const isTutor = screens.aiTutor.classList.contains('active');
                const title = isTutor ? 'AIチューターを終了' : 'クイズを中断';
                const message = isTutor ? 'この学習セッションを終了しますか？' : '本当にクイズを中断しますか？現在の進捗は保存されません。';
                interruptModal.querySelector('.modal-title').textContent = title;
                interruptModal.querySelector('p').textContent = message;
                interruptModal.querySelector('.delete').textContent = isTutor ? '終了する' : '中断する';
                interruptModal.classList.add('show');
            });
            modalCancelInterrupt.addEventListener('click', () => interruptModal.classList.remove('show'));
            modalConfirmInterrupt.addEventListener('click', () => {
                interruptModal.classList.remove('show');
                setActiveProject(activeProjectId);
            });

            modalConfirmDelete.addEventListener('click', handleDeleteProject);
            modalCancelDelete.addEventListener('click', closeDeleteProjectModal);

            nextButton.addEventListener('click', () => { playSound('click'); currentQuiz.currentIndex++; loadQuestion(); });
            toggleExplanationButton.addEventListener('click', () => { 
                explanationContentElement.classList.toggle('show'); 
                toggleExplanationButton.textContent = explanationContentElement.classList.contains('show') ? '解説▲' : '解説▼'; 
            });
            
            restartQuizButton.addEventListener('click', () => {
                const project = appState.projects.find(p => p.id === activeProjectId);
                if (project && currentQuiz) {
                    const originalQuiz = project.quizzes.find(q => q.id === currentQuiz.id);
                    if (originalQuiz) {
                        startQuiz(originalQuiz);
                    }
                }
            });

            backToProjectButton.addEventListener('click', () => setActiveProject(activeProjectId));
            
            projectSettingsButton.addEventListener('click', () => settingsScreen.classList.add('active'));
            backToProjectFromSettings.addEventListener('click', () => settingsScreen.classList.remove('active'));
            settingsScreen.addEventListener('click', (e) => {
                if (e.target === settingsScreen) {
                    settingsScreen.classList.remove('active');
                }
            });
            
            darkModeToggle.addEventListener('change', (e) => setDarkMode(e.target.checked));
            
            themeColorCircles.forEach(circle => {
                circle.addEventListener('click', () => {
                    themeColorCircles.forEach(c => c.classList.remove('selected'));
                    circle.classList.add('selected');
                    setThemeColor(circle.dataset.theme);
                });
            });
            
            soundVolumeSlider.addEventListener('input', (e) => updateVolume(e.target.value));
            soundVolumeSlider.addEventListener('change', saveState);
            
            questionCountSelect.addEventListener('change', (e) => {
                appState.settings.questionCount = parseInt(e.target.value, 10);
                saveState();
            });

            shuffleQuestionsToggle.addEventListener('change', (e) => {
                appState.settings.shuffleQuestions = e.target.checked;
                saveState();
            });

            showProgressToggle.addEventListener('change', (e) => {
                appState.settings.showProgress = e.target.checked;
                saveState();
            });

            masteryModeToggle.addEventListener('change', (e) => {
                appState.settings.masteryMode = e.target.checked;
                saveState();
            });

            editQuizzesButton.addEventListener('click', () => {
                settingsScreen.classList.remove('active');
                showEditQuizzesModal();
            });
            closeEditQuizModalButton.addEventListener('click', () => editQuizzesModal.classList.remove('show'));
            editQuizList.addEventListener('click', handleQuizEditActions);

            renameQuizInstanceModal.querySelector('.save').addEventListener('click', handleRenameQuiz);
            renameQuizInstanceModal.querySelector('.cancel').addEventListener('click', () => renameQuizInstanceModal.classList.remove('show'));
            renameQuizNameInstanceInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleRenameQuiz(); });

            deleteQuizInstanceModal.querySelector('.delete').addEventListener('click', handleDeleteQuiz);
            deleteQuizInstanceModal.querySelector('.cancel').addEventListener('click', () => deleteQuizInstanceModal.classList.remove('show'));

            tosAgreeButton.addEventListener('click', () => {
                localStorage.setItem('qube_tos_agreed', 'true');
                tosModal.classList.remove('show');
            });

            closeAddToHomeScreen.addEventListener('click', () => {
                localStorage.setItem('qube_add_to_home_screen_dismissed', 'true');
                addToHomeScreenPopup.style.display = 'none';
            });
            
            generateTabButton.addEventListener('click', () => {
                generateTabButton.classList.add('active');
                importTabButton.classList.remove('active');
                generateProjectContainer.style.display = 'block';
                importProjectContainer.style.display = 'none';
            });

            importTabButton.addEventListener('click', () => {
                importTabButton.classList.add('active');
                generateTabButton.classList.remove('active');
                importProjectContainer.style.display = 'block';
                generateProjectContainer.style.display = 'none';
            });

            importProjectButton.addEventListener('click', () => {
    handleImportProject();
    importFileInput.value = '';
});

            exportProjectButton.addEventListener('click', () => {
                if(activeProjectId) {
                    handleExportProject(activeProjectId);
                } else {
                    alert('エクスポートするプロジェクトをサイドバーから選択してください。');
                }
            });

            aiTutorButton.addEventListener('click', startAiTutorMode);
            aiTutorInputForm.addEventListener('submit', handleAiTutorSubmit);
            voiceInputButton.addEventListener('click', () => {
                if (!speechRecognition) return;
                if (isRecording) {
                    speechRecognition.stop();
                } else {
                    speechRecognition.start();
                }
            });
            toggleOtherOptionsButton.addEventListener('click', () => {
                const isHidden = otherOptionsContainer.style.display === 'none';
                otherOptionsContainer.style.display = isHidden ? 'block' : 'none';
                toggleOtherOptionsButton.textContent = isHidden ? '他の選択肢を隠す▲' : '他の選択肢を見る▼';
            });

            window.addEventListener('resize', () => {
                const project = appState.projects.find(p => p.id === activeProjectId);
                updateProjectTitle(project?.name || 'Qube');
            });

            init();
        });
    </script>
</body>
</html>
